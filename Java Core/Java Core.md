# СОДЕРЖАНИЕ:

## [Основы JAVA](#основы-java-1) 
- [Полезные заметки](#полезные-заметки) 
- [javadoc](#javadoc) 
- [Компиляция Java кода](#компиляция-java-кода) 
- [Формирование JAR](#формирование-jar)
    - [Компиляция JAR-файла](#компиляция-jar-файла)
    - [Создание манифест-файла](#манифест-файл-manifestmf)
    - [Запуск JAR-файла](#запуск-jar-файлов)
    - [Подключение JAR-файлов](#подключение-jar-файлов)
- [Системы сборки](#системы-сборки)
    - [Maven](#maven)
    - [Gradle](#gradel)
## [Типы данных](#типы-данных-1)
- [Примитивные типы](#примитивные-типы)
- [Var](#var)
- [Ссылочные типы](#ссылочные-типы)
- [Строки](#строки)
    - [Форматирование](#форматирование)
    - [Регулярные выражения](#регулярные-выражения)
- [Сравнение строк](#сравнение-строк)
- [Массивы](#массивы)
- [Сравнения массивов](#сравнения-массивов)
- [Arrays](#arrays)
- [Классы-обертки](#классы-обертки)
- [Преобразования типов](#преобразования-типов)
- [Автоматическое расширение](#автоматическое-расширение)
- [Восходящее преобразование](#восходящее-преобразование)
## [Команды](#команды-1)
- [Вывод информации](#вывод-информации)
- [Вввод информации](#вввод-информации)
- [Математика](#математика)
- [Лигические операции (if, switch)](#логические-операции)
- [Арифметические операции](#арифметические-операции)
- [Побитовые операции](#побитовые-операции)
- [Циклы](#циклы)
- [Функции](#функции)
- [Синтаксис функций](#синтаксис-функций)
- [Перегрузка функции](#перегрузка-функции)
- [lambda Функция](#lambda-функция)
## [ООП](#ооп-1)
- [Принципы ООП](#принципы-ооп)
    - [Инкапсуляция](#инкапсуляция)
    - [Наследование](#наследование)
    - [Полиморфизм](#полиморфизм)
    - [Абстракция](#абстракция)
- [Принципы SOLID](#принципы-solid)
- [Пакеты и import](#пакеты-и-import)
- [Синтаксис class](#синтаксис-class)
- [Наследование и Ключевое слово super](#наследование-и-ключевое-слово-super)
- [Класс Object](#класс-object)
    - [Методы Object](#методы-класса-object)
    - [Реализация equals и hashCode](#реализация-equals-и-hashcode)
        - [Основные принципы реализации метода equals](#основные-принципы-реализации-метода-equals)
        - [Основные принципы реализации метода hashCode](#основные-принципы-реализации-метода-hashcode)
        - [Пример реализации equals и hashCode](#пример-реализации-equals-и-hashcode)
- [Приведение типов (type casting)](#приведение-типов-type-casting)
    - [Пояснение механизма приведения типов](#пояснение-механизма-приведения-типов)
    - [Пример кода приведения типов](#пример-кода-приведения-типов)
- [Ковариантность возвращаемых типов](#ковариантность-возвращаемых-типов)
- [Делегирование](#делегирование)
- [Перечисления](#перечисления)
- [Интерфейсы](#интерфейсы)
- [Функциональные интерфейсы](#функциональные-интерфейсы)
## [Аннотации](#аннотации-1)
## [Обработка ошибок](#обработка-ошибок-1)
## [Логирование](#логирование-1)
## [Работа с файловой системой](#работа-с-файловой-системой-1)
## [Ввод и вывод данных](#ввод-и-вывод-данных-1)
- [FileInputStream](#fileinputstream)
- [java.io.Reader](#javaioreader)
- [InputStreamReader](#inputstreamreader)
- [FileReader](#filereader)
- [BufferedReader](#bufferedreader)
- [FileOutputStream](#fileoutputstream)
- [java.io.Writer](#javaiowriter)
- [OutputStreamWriter](#outputstreamwriter)
- [FileWriter](#filewriter)
- [BufferedWriter](#bufferedwriter)
## [Работа с URL](#работа-с-url-1)
## [Generics](#generics-1)
## [Коллекции и контейнры](#коллекции-1)
- [Collection](#collection)
    - [Основные методы Collection](#основные-методы-collection)
- [List](#list)
    - [Основные методы List](#основные-методы-list)
    - [Реализации List](#реализации-list)
        - [ArrayList](#1-arraylist)
        - [LinkedList](#2-linkedlist)
        - [Vector](#3-vector)
        - [CopyOnWriteArrayList](#4-copyonwritearraylist)
- [Queue](#queue)
    - [Основные методы Queue](#основные-методы-queue)
    - [Реализации Queue](#реализации-queue)
        - [LinkedList](#1-linkedlist)
        - [PriorityQueue](#2-priorityqueue)
        - [ArrayDeque](#3-arraydeque)
        - [ConcurrentLinkedQueue](#4-concurrentlinkedqueue)
        - [LinkedBlockingQueue](#5-linkedblockingqueue)
        - [ArrayBlockingQueue](#6-arrayblockingqueue)
        - [PriorityBlockingQueue](#7-priorityblockingqueue)
        - [SynchronousQueue](#8-synchronousqueue)
- [Deque](#deque)
    - [Основные методы Deque](#основные-методы-deque)
    - [Реализации Deque](#реализации-deque)
        - [ArrayDeque](#1-arraydeque)
        - [LinkedList](#2-linkedlist-1)
        - [ConcurrentLinkedDeque](#3-concurrentlinkeddeque)
        - [LinkedBlockingDeque](#4-linkedblockingdeque)
- [Set](#set)
    - [Основные методы Set](#основные-методы-set)
    - [Реализации Set](#реализации-set)
        - [HashSet](#1-hashset)
        - [LinkedHashSet](#2-linkedhashset)
        - [TreeSet](#3-treeset)
        - [ConcurrentSkipListSet](#4-concurrentskiplistset)
        - [CopyOnWriteArraySet](#5-copyonwritearrayset)
- [Map](#map)
    - [Основные методы Map](#основные-методы-map)
    - [Реализации Map](#реализации-map)
        - [HashMap](#1-hashmap)
        - [LinkedHashMap](#2-linkedhashmap)
        - [TreeMap](#3-treemap)
        - [ConcurrentHashMap](#4-concurrenthashmap)
- [Optional](#optional)
## [Stream API](#stream-api-1)

## ПРОЧИЕ ССЫЛКИ:
- [Модификаторы доступа](#модификаторы-доступа)
- [Ключевые слова классов](#ключевые-слова-классов)
- [Ключевые слова переменных](#ключевые-слова-переменных-1)
- [Ключевые слова методов](#ключевые-слова-методов)
- [Модификаторы](#модификаторы)
- [Типы возвращаемых данных](#типы-возвращаемых-данных)
- [Специальные символы](#специальные-символы)

# Основы JAVA
    Java - компилируемый, строго типизированный объектно-ориентированный язык программирования общего назначения
    В Java исопльзуется кодировка Unicode-16

    Терминология:

    JDK(Java Development Kit) - комплект разработчика, включающий в себя компилятор
    JAR(Java ARchive) - это Java-архивы, в которых содержатся компоненты программы (без зависимых библиотек)
    UBER JAR(Uber Java ARchive) - это Java-архивы, в которых помещены все зависымые библиотеки
    JVM(Java Virtual Machine) - виртульная машина Java, благодаря ей можно запускать скомпилированный Java-код
    JRE(Java Runtime Environment) - виртуальная машина, для запуска Java-приложений (состоит из JVM и библиотека Java-классов)
    JIT(Just-in-time compilation) - компилятор, который переводит код в байт-код, который выполняет компьютер

## Полезные заметки

**Изменить версию java** по умолчанию в системе Mac (JDK нужной версии должен быть установлен)
```shell
    export JAVA_HOME=$(/usr/libexec/java_home -v VERSION)
    export PATH=$JAVA_HOME/bin:$PATH
```

## Компиляция java кода
```shell
    javac [Main.java] # Команда для компиляции файлов (будет создан файл Main.class)
    java Main # Запустить скомпилированный файл (.class указывать не нужно)
    javac -d bin ./src/*.java  # Скомпилировать все файлы из папки и записать результат в bin
    javac -cp lib1.jar:lib2.jar -d bin ./src/*.java # Скомпилировать проект с использованием сторонних библиотек
    java -classpath ./bin Main # Запуск проекта из папки bin
    #    * -classpath можно задать -cp
    java -classpath ./bin:MyJar1.jar:MyJar2.jar Main # Запуск проекта из папки bin с подключением jar файлов

    # Если класс принадлежит пакету, то компиляция выглядит следующим образом
    javac package/Main.java
    java package.Main
```
## Формирование JAR

### Компиляция JAR-файла

Создание JAR-файла осуществляется с использованием инструмента `jar`, который входит в состав JDK. Инструмент `jar` предоставляет различные флаги для управления процессом создания JAR-файлов.

Опция `-C` в команде `jar` используется для указания каталога, в котором находятся файлы для включения в архив JAR. В вашем примере `-C classes/` означает, что содержимое каталога `classes/` будет включено в JAR-файл. 

Например, если у вас есть структура каталогов следующего вида:
```
classes/
    com/
        example/
            MyClass.class
            AnotherClass.class
```
Использование `-C classes/` гарантирует, что содержимое каталога `classes/` будет включено в JAR-файл, а не просто сам каталог.

### Основные флаги для создания JAR-файла
```shell
    jar cf myfile.jar -C classes/ . # `c` Создать новый JAR-файл
    jar cf myfile.jar -C classes/ . # `f` Указать имя выходного файла JAR.
    jar cfm myfile.jar MANIFEST.MF -C classes/ . # `m` Включить манифест-файл
    jar tf myfile.jar # `t` Показать содержимое JAR-файла
    jar xf myfile.jar # `x` Извлечь содержимое из JAR-файла
    jar jar uf myfile.jar -C new_classes/ . # `u` Обновить существующий JAR-файл
    jar cvf myfile.jar -C classes/ . # `v` Включить подробный вывод
    jar cf0 myfile.jar -C classes/ . # `0` Создать JAR-файл без сжатия.
```

### Манифест файл MANIFEST.MF

Манифест-файл указывает метаданные о содержимом JAR-файла, включая точку входа для исполняемых JAR-файлов. Создайте файл `MANIFEST.MF` со следующим содержимым:
```makefile
    Manifest-Version: 1.0
    Main-Class: MyClass
```
Манифест указывает, что `MyClass` содержит метод `main` и является точкой входа для JAR-файла.

Файл `MANIFEST.MF` в JAR-файле может содержать следующую информацию:

```makefile
    Manifest-Version: 1.0 # Версия спецификации манифеста. Обычно это "1.0"
    Main-Class: com.example.Main # Имя класса с методом `main`, который будет точкой входа при запуске JAR-файла
    Class-Path: lib/library1.jar lib/library2.jar # Путь к зависимым JAR-файлам. Разделяется пробелами
    Implementation-Title: MyApp # Название программы
    Implementation-Version: 1.0 # Версия программы
    Implementation-Vendor: MyCompany # Поставщик программы
    Specification-Title: MyApp Specification # Название спецификации, которую реализует программа
    Specification-Version: 1.0 # Версия спецификации
    Specification-Vendor: MyCompany # Поставщик спецификации
    Sealed: true # Указывает, что пакет в JAR-файле должен быть запечатан. Если указано "true", все классы в этом пакете должны быть из одного JAR-файла
    Built-By: DeveloperName # Информация о сборщике (например, имя разработчика)
    Created-By: 1.8.0_201 (Oracle Corporation) # Инструмент, использованный для создания JAR-файла
    Signature-Version: 1.0 # Версия подписи JAR-файла
```

### Запуск JAR-файлов
```shell
    java -jar MyApp.jar # Запуск исполняемого JAR-файла, содержащего точку входа, указанную в манифесте
```

### Подключение JAR-файлов

Для использования JAR-файлов в вашем проекте (например, в качестве библиотек), нужно указать их в класспасе (`classpath`). Есть несколько способов это сделать.

```shell
    java -cp MyLibrary.jar com.example.Main # Указание в командной строке
    java -cp lib1.jar:lib2.jar com.example.Main # Указание нескольких JAR-файлов
    #   * На Windows используйте точку с запятой (`;`) вместо двоеточия (`:`)
    java -cp "lib/*" com.example.Main # Использование wildcard для указания всех JAR-файлов в директории
```

## javadoc

`javadoc` позволяет писать документацию к классам и методам проекта.
Не пишет документацию для private и доступа в пределах пакета

```java
    /**
    Комментарий для документации (javadoc)
    В данном блоке можно использовать HTML заметку

    @see Ссылка_на_другие_классы - указывает ссылку на другой класс в тексте отмечается, как смотри также, например, @see полное-имя-класса#имя-метода
    @author: Dmitriy Bachinin
    @version: 1.5
    {@link пакет.класс#член_класса метка} - ссылка на другой класс, может иметь любой текст (в отличии от @see)
    {@docRoot} - получение относительного пути к корневой папке, в которой находится документация
    {@inheritDoc} - наследование документации базового класса, ближайшего к документируемому
    @since 1.3 - позволяет задать версию кода, с которой началось использование некоторой функции
    @param имя-параметра описание - полезен для документации методов, где имя-параметра - это индентификатор параметров в списке параметров метода
    @return описанание - объяснение того, что именно возвращает метод
    @throws полное_имя_класса_ошибки описание - указывает какие исключения способен вызвать данный метод при своем вызове
    */
```

# Типы данных

## Примитивные типы
Примитивные типы - это типы данных, которые непосредственно записываются в память
```java
    boolean - логический тип
    char - символьный тип (число от 0 до 2^16) - хранит номер в символа в кодировке Unicode (с данным типом данных доступны #Побитовые операции#)
    char literal = 'a'; - запись одного сивола происходит при помощи одинарных ковычек
    char hex = '\u03A9' - запись любого символа при помощи номера юникод
    byte(1 байт), short(2 байта), int(4 байта), long(8 байт) - целочисленные типы, которые отличаются емкостью
    int decimal = 99; - число в десятичной системе счисления(10)
    int octal = 0755; - число в восьмеричной системе счисления(8)
    int hex = 0xFF; - число в шестнадцатеричной системе счисления(16)
    int binary = 0b101; - число в двоичной системе счисления(2)
    int tenMillion = 10_000_000; - в записи числа можно испольщовать _ для улучшения читабельности
    long tenBillion = 10_000_000_000L; - если число не помещается в int, то ему необходимо добавить "L", чтобы сказть компилятору, что число long
    float (32 бита), double (64 бита) - вещественные типы, которые отличаются емкостью
    * Диапозон значений вещественных типов определяется по формуле +-m*2^e, где m - мантисса (у float = 23, у double = 52), e - экспонента (у float = 8, у double = 11). 1 Бит выделяется под знак
    double simple = -1.234; - стандарная запись вещественного числа
    double exponential = -123.4e-2; - эксоненциальная запись вещественного числа = -123,4 * 10^-2 (e-n = 10^-n)
    double hex = 0x1.Fp10; - эксоненциальная запись шестнадцатеричного числа = 1.F * 2^10 (pn = 2^n)
    float floatWithSuffix = 36.6f; - все вещественные числа по умолчанию имеют тип double, для преобразования его во float необходимо дописать суффикс f
    double doubleWithSuffix = 4d; - суффикс для явного указания на тип double
    ** Поддерживают #Арифметические операции# но не #Побитовые операции#
    Особые случаи:
    double positivelInfinify = 1.0 / 0.0; -> +inf(беспонечность) - любые опрерации над inf будут иметь смысл, например, 1 + inf = inf
    double negativeInfinify = -1.0 / 0.0; -> -inf(беспонечность)
    double nan = 0.0 / 0.0; -> nan (Not a Number). nan != nan -> true
    ** Для сравнения вещественных чисел используют конструкцию |a - b| < E
```

## Var

В Java ключевое слово `var` было введено в версии Java 10 и предназначено для локальной типизации переменных. Это означает, что компилятор Java может выводить тип переменной из инициализирующего выражения. Использование var упрощает код, делая его более читаемым и менее многословным, особенно при использовании сложных типов.

Основные моменты, которые следует учитывать:
1. `Только для локальных переменных`: var может использоваться только для локальных переменных внутри методов, конструкций циклов, инициализации и блоков инициализации. Его нельзя использовать для полей класса, параметров методов или возвращаемых типов методов.
2. `Явная инициализация`: Переменная, объявленная с помощью var, должна быть инициализирована в момент объявления, чтобы компилятор мог вывести тип.
3. `Читаемость кода`: Хотя var может упростить синтаксис, важно использовать его с осторожностью, чтобы не ухудшить читаемость кода. Например, в случаях, когда тип не очевиден, лучше явно указать его.

### Пример
```java
var message = "Hello, World!"; // Компилятор выводит тип String
var user = new User("John", "Doe"); // Компилятор выводит тип User

var value;  // Ошибка: переменная должна быть инициализирована
```

## Ссылочные типы

`Ссылочные типы` - это тип данных, в память записывается ссылка на адрес, содержащий ссылку на сам объект в памяти <br>
* Любой переменной данного типа можно присвоить null

## Строки
    Строки являются неизменяемым типом данных
```java
    String str = "Hi"; // строка
    char[] charArray = str.toCharArray(); // преобразование строки в массив символов
    int length = str.length(); // получение длины строчки
    char charAtIdx = str.charAt([idx]); // получение символа по индексу
    boolean startWithTable = str.endsWith("[String]"); // начинается ли строка на [String]
    boolean endsWithTable = str.endsWith("[String]"); // заканчивается ли строка на [String]
    boolean isContains = str.contains("[String]"); // есть ли строка [String] в str
    String concatStr = str.concat("[String]"); // конкатинация (соединение) 2-х строк
    String substring = str.substring([start_idx], [end_idx]); // вырезать подстроку из строки от start_idx до end_idx (не включительно)
    String[] strArray = str.split("[reg]", int limit); // разделение строки по шаблону limit раз
    String afterReplace = str.replace("[Old String]", "[new String]"); // заменить все подстроки на другие
    String allCapitals = str.toUpperCase(); // перевод строки в заглавному регистру
    String allSmall = str.toLowerCase(); // перевод строки к строчному регистру
    String regString = str.replaceAll("[reg]", "[String]"); // заменить фрагменты строки, которые подходят по регулярному выражению
    * [^a-zA-Z0-9] // шаблон описывает латинские символы без учета регистра
    int position = str.indexOf(ch) // возавращает позицию первого вхождения символа в строку
    int position = str.lastIndexOf(ch) // возавращает позицию последнего вхождения символа в строку

    StringBuilder sb = new StringBuilder("[start String]"); // создание объекта StringBuilder, который похож на строку, но допускает изменение содержимого
    // ДОКУМЕНТАЦИЯ: https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/StringBuilder.html#capacity()
    sb.append("[String]"); // добавление строки [String] в последовательность StringBuilder
    sb.delete([start_idx], [end_idx]) // удаление подстроки из строки
    sb.indexOf("[String]", [idx]); // возвращает индекс в этой строке первого вхождения указанной подстроки, начиная с указанного индекса (если idx указан)
    sb.insert([element], [idx]); // втавляет указанный элемент в указанное место
    sb.length() // возвращает длину (количество символов)
    sb.reverse() // обратное отражение последовательности
    String str = sb.toString(); // перевод объекта StringBuilder в String
```

### Форматирование:
    ДОКУМЕНТАЦИЯ: https://rukovodstvo.net/posts/id_590/
```java
    System.out.printf("%[спецификатор типа]", args);
    String s = String.format("%[спецификатор типа]", args); форматирование строки и возвращение результата

    Спецификаторы типов:
    %c - символ
    * Можно указывать в виде "{code Point}"(например, "0x11FFFF")
    %d - десятичное число (основание 10)
    %i - целое число (основание 10)
    %o - восьмеричное число (основание 8)
    %u - беззнаковое десятичное (целое) число
    %x - шестнадцатеричное число (основание 16)
    %e - экспоненциальное число с плавающей запятой
    %f - число с плавающей запятой
    %s - Строка
    %t - Дата / время
    %te - день из даты
    %tm - месяц из даты
    %tY - год в формате 3-х цифр
    %n - Новая строка

    Инструкции спецификатора:
    %[аргумент_индекс][флаги][ширина][.точность][спецификатор типа] - шаблон инструкции для спецификатор

    [аргумент_индекс] — целое число, указывающее позицию в списке аргументов. К примеру, ссылка на первый аргумент 1$, ссылка на второй аргумент — 2$, и т.д.
    Если же позиция не была задана, аргументы должны находиться в том же порядке, что и ссылки на них в строке форматирования.
    [флаги] — специальные символы для форматирования. Например:
    + флаг, означающий, что если числовое значение положительное, оно должно включать знак +
    - означает выравнивание результата по левому краю
    , устанавливает разделитель тысяч у целых чисел
    [ширина] — положительное целое десятичное число, определяющее минимальное количество символов, которые будут выведены. Если перед этим числом стоит 0, то недостающие символы будут дополнены 0, если 0 нет, то пробелами.
    [.точность] — неотрицательное целое число с точкой перед ним. Как правило используется для ограничения количества символов. Специфика поведения зависит от конкретного вида спецификатора.

    Примеры:
    String s = String.format("%2$s, %1$s", "str1","str2"); - обращение к разным элементам по индексу
    * Вывод: "str2, str1"
    String s = String.format("%1$+09.5f", 3.1415926535897);
    * Вывод: +03,14159

    Форматирование чисел
    DecimalFormat — класс для форматирования любого числа в Java, будь то целое число или число с плавающей запятой
    String s = new DecimalFormat( "[шаблон]" ).format(Number)

    Элементы для написания шаблонов:
    [ — цифра, ведущие нули опускаются
    0 — цифра отображается всегда, даже если в номере меньше цифр (в таком случае отображается 0)
    . — знак десятичного разделителя
    , — знак группировки разделителей (например, разделитель тысяч)
    ; — разделяет форматы
    - — отмечает префикс отрицательного числа
    % — умножает на 100 и показывает число в процентах
    ? — умножает на 1000 и показывает число в промилле
    E — разделяет мантиссу и порядок для экспоненциального формата

    Примеры:
    System.out.println(new DecimalFormat( "###,###.##" ).format(74554542.224463));
    * Вывод: 74 554 542,22
    System.out.println(new DecimalFormat( "%###.##" ).format(0.723456));
    * Вывод: %72,35
    System.out.println(new DecimalFormat( "000.###" ).format(42.224463));
    * Вывод: 042,224

    ** При обрезании числа со знаками после запятой, выходящими за заданный шаблон,
    DecimalFormat округляет число в большую сторону, если последнее обрезаемое число больше 5.
```
### Регулярные выражения:
    ДОКУМЕНТАЦИЯ: https://javarush.com/groups/posts/regulyarnye-vyrazheniya-v-java
```java
    Pattern pattern = Pattern.compile("[RegEx]", int flags); - компиляция шаблона регулярного выражения
    * flags - определяет дополнительные возможности для регулярного выражения
    Pattern.CANON_EQ - обеспечивает каноническую эквивалентность
    Pattern.CASE_INSENSITIVE - включает сопоставление без учета регистра
    Pattern.COMMENTS - разрешает пробелы и комментарии в шаблоне

    Метасимволы для поиска совпадений границ строк или текста:
    ^	- начало строки
    $	- конец строки
    \b	- граница слова
    \B	- не граница слова
    \A	- начало ввода
    \G	- конец предыдущего совпадения
    \Z	- конец ввода
    \z	- конец ввода

    Метасимволы для поиска символьных классов:
    \d	- цифровой символ
    \D	- нецифровой символ
    \s	- символ пробела
    \S	- непробельный символ
    \w	- буквенно-цифровой символ или знак подчёркивания
    \W	- любой символ, кроме буквенного, цифрового или знака подчёркивания
    .	- любой символ

    Метасимволы для поиска символов редактирования текста:
    \t	символ табуляции
    \n	символ новой строки
    \r	символ возврата каретки
    \f	переход на новую страницу

    Метасимволы для группировки символов:
    [абв] - любой из перечисленных (а,б, или в)
    [^абв] - любой, кроме перечисленных (не а,б, в)
    [a-zA-Z] - слияние диапазонов (латинские символы от a до z без учета регистра )
    [a-d[m-p]] - объединение символов (от a до d и от m до p)
    [a-z&&[def]] - пересечение символов (символы d,e,f)
    [a-z&&[^bc]] - вычитание символов (символы a, d-z)

    Метасимволы для обозначения количества символов – квантификаторы.
    * Квантификатор всегда следует после символа или группы символов.
    ? - один или отсутствует
    * - ноль или более раз
    + - один или более раз
    {n} - n раз
    {n,} - n раз и более
    {n,m} - не менее n раз и не более m раз

    **Режимы квантификаторов:
    [квантификатор] - жадный режим (обычный) - находит максимально большое совпадение
    [квантификатор]+ - сверхжадный режим - находит максимально большое совпадение, которое должно заканчиваться в конце строки
    [квантификатор]? - ленивый режим - находит самые первые совпадения
```

## Сравнение строк
```java
    boolean referenceEquals = str1 == (str2); // сравнивает ссылки двух переменных, а не содержимое
    boolean contetEquals = str1.equals(str2); // сравнение двух строк по содержимому
    boolean contetEqualsIgnoreCase = str1.equalsIgnoreCase(str2); // сравнение содержимого строк, игнорируя регистр
```
## Массивы
```java
    [type][] [name]; // объявление массива определенных данных
    int[] numbers = new int[len] // создает массив целых чисел размера len
    boolean bools[] = new boolean[len] // альтернативные способ создания массива
    * При инициализации массив заполняется значениями по умолчанию (int -> 0, boolean -> false, Ссылки -> null)
    ** Размер массива изменить нельзя
    Object[] objectArr = new Object[]{new Integer(1), new Float(2.3)} // пример создания массива объектов, в который можно положить любые объекты

    int[] numbers = new int[] {1,2,3,4,5}; // задание массива с заполнением
    * Данная запись позволяет создать заполненный массив где угодно, например, при передаче параметра в функцию
    int[] numbers = {1,2,3,4,5}; // краткая форма задания массива с заполнением (работает, если переменная объявляется и инициализируется в одной строчке)

    int len = numbers.length; // получение длины массива
    int element = numbers[id]; // получение элемента по id

    int[][] matrix = new int[len][len]; // объявление двумерного массива
    int[][] matrix = {{1,2},{3,4,5}, null, {6}}; // альтернативное объявление двумерного массива (можно задать произвольный размер для вложенных массивов)
```

### Сравнения массивов
```java
    int[] a = {1,2,3}; int[] b = {4,5,6}; // объявление массивов
    a == b; // оператор сравнивает ссылки объектов, т.е. ссылаются ли переменные на один и тот же объект
    Arrays.equals(a, b); // сравнение массивов по содержимому (на первом уровне вложенности)
    Arrays.deepEquals(matrix1, matrix2); // сравнение массивов по содержимому (на всех уровнях вложенности)
    Arrays.toString(a); // преобразование массива в строку (на первом уровне вложенности)
    Arrays.deepToString(matrix); // преобразование массива в строку (на всех уровнях вложенности)
    * import java.util.Arrays; // импорт класса Arrays(очень полезный класс для работы с массивами)
```

### Arrays

Класс `Arrays` в Java находится в пакете java.util и предоставляет множество статических методов для работы с массивами. Эти методы включают сортировку, поиск, сравнение, копирование и преобразование массивов. Класс Arrays облегчает манипуляции с массивами, делая код более компактным и удобочитаемым.

ДОКУМЕНТАЦИЯ: [Arrays](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Arrays.html)

Класс `Arrays` в Java находится в пакете `java.util` и предоставляет множество статических методов для работы с массивами. Эти методы включают сортировку, поиск, сравнение, копирование и преобразование массивов. Класс `Arrays` облегчает манипуляции с массивами, делая код более компактным и удобочитаемым.

### Основные методы класса `Arrays`

#### 1. Сортировка

- **`sort`**: Сортирует массивы в порядке возрастания.
  - **Сигнатуры**:
    ```java
    static void sort(int[] a)
    static void sort(double[] a)
    static void sort(Object[] a)
    static <T> void sort(T[] a, Comparator<? super T> c)
    ```

  - **Пример**:
    ```java
    int[] arr = {3, 1, 4, 1, 5};
    Arrays.sort(arr);
    System.out.println(Arrays.toString(arr));  // [1, 1, 3, 4, 5]
    ```

#### 2. Поиск

- **`binarySearch`**: Выполняет бинарный поиск в отсортированном массиве.
  - **Сигнатуры**:
    ```java
    static int binarySearch(int[] a, int key)
    static int binarySearch(double[] a, double key)
    static <T> int binarySearch(T[] a, T key, Comparator<? super T> c)
    ```

  - **Пример**:
    ```java
    int[] arr = {1, 2, 3, 4, 5};
    int index = Arrays.binarySearch(arr, 3);
    System.out.println(index);  // 2
    ```

#### 3. Сравнение

- **`equals`**: Сравнивает два массива на равенство.
  - **Сигнатуры**:
    ```java
    static boolean equals(int[] a, int[] a2)
    static boolean equals(double[] a, double[] a2)
    static boolean equals(Object[] a, Object[] a2)
    ```

  - **Пример**:
    ```java
    int[] arr1 = {1, 2, 3};
    int[] arr2 = {1, 2, 3};
    boolean areEqual = Arrays.equals(arr1, arr2);
    System.out.println(areEqual);  // true
    ```

#### 4. Копирование

- **`copyOf`**: Копирует массив в новый массив указанной длины.
  - **Сигнатуры**:
    ```java
    static int[] copyOf(int[] original, int newLength)
    static double[] copyOf(double[] original, int newLength)
    static <T> T[] copyOf(T[] original, int newLength)
    ```

  - **Пример**:
    ```java
    int[] arr = {1, 2, 3};
    int[] newArr = Arrays.copyOf(arr, 5);
    System.out.println(Arrays.toString(newArr));  // [1, 2, 3, 0, 0]
    ```

- **`copyOfRange`**: Копирует диапазон из одного массива в новый массив.
  - **Сигнатуры**:
    ```java
    static int[] copyOfRange(int[] original, int from, int to)
    static double[] copyOfRange(double[] original, int from, int to)
    static <T> T[] copyOfRange(T[] original, int from, int to)
    ```

  - **Пример**:
    ```java
    int[] arr = {1, 2, 3, 4, 5};
    int[] newArr = Arrays.copyOfRange(arr, 1, 4);
    System.out.println(Arrays.toString(newArr));  // [2, 3, 4]
    ```

#### 5. Заполнение

- **`fill`**: Заполняет массив указанным значением.
  - **Сигнатуры**:
    ```java
    static void fill(int[] a, int val)
    static void fill(double[] a, double val)
    static void fill(Object[] a, Object val)
    ```

  - **Пример**:
    ```java
    int[] arr = new int[5];
    Arrays.fill(arr, 1);
    System.out.println(Arrays.toString(arr));  // [1, 1, 1, 1, 1]
    ```

#### 6. Преобразование

- **`toString`**: Возвращает строковое представление массива.
  - **Сигнатуры**:
    ```java
    static String toString(int[] a)
    static String toString(double[] a)
    static String toString(Object[] a)
    ```

  - **Пример**:
    ```java
    int[] arr = {1, 2, 3};
    String arrStr = Arrays.toString(arr);
    System.out.println(arrStr);  // [1, 2, 3]
    ```

- **`asList`**: Преобразует массив в список фиксированной длины.
  - **Сигнатура**:
    ```java
    static <T> List<T> asList(T... a)
    ```

  - **Пример**:
    ```java
    String[] arr = {"A", "B", "C"};
    List<String> list = Arrays.asList(arr);
    System.out.println(list);  // [A, B, C]
    ```

#### 7. Параллельные операции

- **`parallelSort`**: Сортирует массив параллельно.
  - **Сигнатуры**:
    ```java
    static void parallelSort(int[] a)
    static void parallelSort(double[] a)
    static <T> void parallelSort(T[] a, Comparator<? super T> c)
    ```

  - **Пример**:
    ```java
    int[] arr = {5, 3, 8, 1, 2};
    Arrays.parallelSort(arr);
    System.out.println(Arrays.toString(arr));  // [1, 2, 3, 5, 8]
    ```

## Классы-обертки
Классы-обертки: - это двойнеки для примитивных типов, но они являются ссылочными типами
* Полезны, чтобы хранить значения в коллекции <br>
ДОКУМЕНТАЦИЯ: https://javarush.com/groups/posts/1948-objertki-raspakovka-i-zapakovka
```java
    Примеры классов-оберток:
    boolean -> Boolean
    byte -> Byte
    short -> Short
    int -> Integer
    Integer.parseInt("[String]" int [radix]); - преобразует строку в число, radix указывает систему счисления (до 36 включительно),  в какой системе счисления изначально записано число в String
    Integer.toBinaryString(int [А]); - преобразование числа в двоичный код
    Integer.bitCount(int [А]); - считает количестов бит = 1 в числе
    // ДОКУМЕНТАЦИЯ: https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/Integer.html
    long -> Long
    char -> Character
    float -> Float
    double -> Double

    Методы для классов-оберток:
    [класс-обертка].valueOf([type] [A]) - привести переменную из приметивного типа в обертку (boxing)
    [класс-обертка].parse[type]("[String]"); - преобразует строку в определенный type
    [класс-обертка].toString([type] [A]); - преобразование А в строку
    [A].[type]Value(); - преобразование переменной А из класса-обертки в приметивный тип (unboxing)

    Полезные методы:

    short maxShortValue = Short.MAX_VALUE; - возвращает максимальное значение для данного примитива
    short minShortValue = Short.MIN_VALUE; - возвращает минимальное значение для данного примитива
    boolean isLetter = Character.isLetter('a'); - проверяет, совпадают ли данные символы
    float floatInfinity = Float.POSITIVE_INFINITY; - возвращает +inf c типом float
    double doubleNaN = Double.NaN; - пустое значение double
    boolean isNaN = Double.isNaN(doubleNaN); - проверка на Double.NaN значение
```
## Преобразования типов
```java
    double pi = Math.PI;
    int intPi = (int) pi; - преобразование одного типа в другой
```
## Автоматическое расширение
Автоматическое расширение - приведение аргументов к одному типу при выполнении операций
```java
    double doubleValue = 1d + 1f; - если одно из значений double, то все остальные переменные тоже приводятся к double
    float floatValue = 1f * 1; - если одно из значений float, то все остальные переменные тоже приводятся к float
    long longValue = 1L - 'O'; - если одно из значений long, то все остальные переменные тоже приводятся к long
    ** Если ни одно из правил не сработало, то все числа приводятся к типу int!
    Пример:
    byte a=1; byte b=2; byte c = (byte) (a+b); - при сложении двух переменных с типом byte результат будет в int
    Из-за этого при a += 3 (a = (byte) (a + 3))
```
## Восходящее преобразование
Восходящее преобразование - процесс преобразования объекта от дочернего класса к родительскому
```java
    Share s = new Circle();
    * Объект Circle является дочерним классом от Share, поэтому преобразование уместно
    * При подобном преобразовании новые методы класса Circle будут проигнорированны, будет учитываться только интерфес класса Share
    * Если переопределить метод в Circle, который есть в Share, то при восходящем приобразовании переопределенный метод останится у нового объекта
    ** Данное преобразование справедливо при передаче объектов в функцию, например: в square(Share s) можно спокойно передать объект Circle
    ** Статические методы не поддерживают полиморфного поведения и не переопределются при восходящем приобразовани, так как определяются на уровне класса
```
## Восходящее преобразование
Нисходящее преобразование - процесс преобразования объекта от родительского класса к дочернему <br> ! Небезопасная операция !
```java
    Ex ex = new Ex_2();
    (Ex_2)ex - пример нисходящего преобразования
```
## Команды

## Вывод информации:
```java
    System.out.print("[Инф]"); // Команда для вывода информации
    * Несколько подряд идущих команд принт будут сливаться в одну строку без переносов и пробелов.
    System.out.println("[Инф]") // В конце каждой строчки ставит \n
    System.out.printf("[Инф] %[params]",params); // Команда для вывода информации с форматированием строки
```
* [Форматирование](#форматирование)

## Вввод информации:
```java
    import java.util.Scanner; // Подключение класса для работы с вводом
    Scanner in = new Scanner(System.in); // Насройка сканера на ввод из консоли
    String str = in.nextLine(); // Получение строки из источника ввода
    int num = in.nextInt(); // Получение целого числа из источника ввода
```

## Математика

    Класс Math:
    ДОКУМЕНТАЦИЯ: https://javarush.com/groups/posts/2762-klass-java-math-i-ego-metodih
    * Класс Math располагается в пакете java.lang
```java
    Math.abs([Number]); // возращает модуль данного числа
    Math.toDegrees(double [angrad]) // переводит угол angrad, измеряемый в радианах, в градусы
    Math.toRadians(double [angdeg]) // переводит угол angdeg, измеряемый в градусах, в радианы
    Math.sin(Math.toRadians([angdeg])) // вычисление синуса от радиан
    Math.cos(Math.toRadians([angdeg])) // вычисление косинуса от радиан
    Math.pow(double [A], double [B]) // возведение числа A в степень B
    Math.sqrt(double [A]) // корень из числа
    Math.cbrt(double [A]) // кубический корень из числа
    Math.random() // возвращает случайное число от 0.0 до 1.0
    Math.round(double [A]) // округление числа до целого значения по правилам математики
    Math.floor(double [A]) // округление числа в меньшую сторону до целого
    Math.ceil(double [A]) // округление числа в большую сторону до целого
    Math.PI // возвращает число Пи
    Math.E // возвращает число Е
    Math.max([A], [B]) // возвращает наибольшее число из двух
    Math.min([A], [B]) // возвращает минимальное число из двух

    BigInteger // целые числа, которые могут быть очень большими
    BigDecimal // вещественные числа, которые могут быть очень большими
    * данные классы необходимо имортировать import java.math *;
    ДОКУМЕНТАЦИЯ: https://metanit.com/java/tutorial/12.2.php
```
## Случайные числа
```java
    ДОКУМЕНТАЦИЯ: https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Random.html

    Random rand = new Random({seed}) // Cоздает новый тип генератора случайных чисел
    * если в seed вписать число самостоятельно, то рандом перестанет быть случайным и будет повторяться каждый раз
    * если ничего не указывать в параметрах метода, тогда значения будут случайными при каждом запуске программы
```
## Логические операции
```java
    Операции сравнения: >,<,>=,<=, ==, !=
    Операции над логическими типами:
    && - логическое "И" (по сокращенной схеме, т.е если A = 0, то B не вычисляется).
    & - логическое "И" (по полной схеме, т.е вычисляются А и В)
    || - логическое "ИЛИ" (по сокращенной схеме, т.е если A = 1, то B не вычисляется)
    | - логическое "ИЛИ" (по полной схеме, т.е вычисляются А и В)
    ! - логическое "НЕ"
    ^ - логическое "исключающее ИЛИ" (возвращает true, если A != B, формула А*!В + !А*В)

    value &= exp; - краткая записи выражения value = value & exp;

    // Оператор if

    if (condition){ ... }
    else if (condition) { ... }
    else { ... }

    * Если под оператором исопльзуется только одно дейтсвие то {} можно не ставить:
    if (condition)
    [move];
    else
    [move];

    (anObject instanceof [ClassName]) - проверяет, является ли данный объект экземпляром заданного класса

    Тернарный условный оператор:
    (condition) ? [valIsTrue] : [valIsFalse] - запись условия в одну строчку

    // Оператор switch

    switch ([param]){
    case [val1]: - попадает сюда, если param == val1
    [move1];
    break; - если не писать "break", то выполнение перейдет на следующий case без проверки его условия
    case [val2]:
    [move2];
    break;
    default: - попадает сюда, если не нашлось совпадения со значением param
    [default move];
    }
    * Ветвления доступны по типам: int, String, char
```
## Арифметические операции
```java
    int sum = a + b; - сложение двух чисел, краткая запись (a += b)
    int diff = a - b; - разность двух чисел, краткая запись (a -= b)
    int div = a / b; - целочисленные деление двух целых чисел, краткая запись (a /= b)
    int rem = a % b; - остаток от деления двух чисел, краткая запись (a %= b)
    int mult = a * b; - умножение двух чисел, краткая запись (a *= b)
    a = a + 1 => a++, возращает значение a, если ++a, то вернется значение a+1
    a = a - 1 => a--, возращает значение a, если --a, то вернется значение a-1
```
## Побитовые операции
    ДОКУМЕНТАЦИЯ: https://javarush.com/groups/posts/1925-pobitovihe-operacii
```java
    int neg = ~a; // применение отрицания к каждому биту числа
    int and = a & b; // попарное применение & между битами 2-х чисел
    int or = a | b; // попарное применение | между битами 2-х чисел
    int xor = a ^ b; // попарное применение ^ между битами 2-х чисел
    Пример:
    a = 0001
    b = 0101
    and = 0001 // a & b
    or = 0101 // a | b
    xor = 0100 // a ^ b
    int arithmeticShiftRight = a >> [int count]; // сдвиг битов числа на count позиций вправо (деление на 2)
    * Если входное число отрицательное, где крайний левый бит равен 1, то пустые места будут заполнены 1
    * Если входное число положительное, где крайний левый бит равен 0, то пустые места будут заполнены 0
    int arithmeticShiftRight = a >>> [int count]; // сдвиг битов числа на count позиций вправо (деление на 2)
    * При таком сдвиге слева всегда дописываестся 0 (Результатом всегда будет положительное целое число)
    int shiftLeft = a << [int count]; // сдвиг битов числа на count позиций влево (умножение на 2)
    * При нем теряются старшие биты а младшие заполняются нулями
```
## Циклы
```java
    [tagName]:
    while(condition){ ... } // пока условие выполняется цикл будет продолжать выполнение
    * [tagName]: // позволяет задать имя для цикла, что позволит указать конкретный цикл в операторах break tagName; и continue tagName; в коде, чтобы завершить конкретный цикл по его имени

    do{ ... }while(condition); // цикл с постусловием, в нем первая операция выполняется всегда

    [tagName]: // присвоение названия функции для возможности использовать break; или continue; на определенный цикл
    for ([инициализация переменной счетчика]; [условие прекращения итераций]; [дейтсвие, которое выполяется после каждой итерации]){ ... } // шаблон для создания цикла for
    for (int i=0; i<[maxVal]; i++){ ... } // цикл со счетчиком (стандарная запись)
    for ([type] arg : args){ ... } // перебор всех элементов массива

    * break tagName; // досрочно завершает цикл
    * continue tagName; // переход к следующей итерации цикла
```
# Функции:

## Синтаксис функций
```java
    [#Модификаторы доступа#] [#Модификаторы#] [#Ключевые слова методов#] [#Типы возвращаемых данных#] [Имя]([тип параметра] [имя параметра]) {body} - шаблон для создания функции
    * Если в данном методе может вызываться ошибка с типом #Проверяемые#, то при создании функции после параметров ставится throws -> ... [Имя]([тип параметра] [имя параметра]) throws [Exception1], [Exception2]

    public static void main(String[] args){body} - написание функции main, которая выполняется при запуске программы
    * в переменную args записываются переменные из командной строки
    static int func(int... numbers){body} - конструкция с ... позволяет передать любое количество переменных, например, func(1,2,3,4) -> numbers = {1,2,3,4}
    * Можно передать массив, что будет обработанно корректно
    * Можно передать 0 аргументов
```
## Перегрузка функции - использование одного имени функции, только с разными именами
```java
    void f() {} 	  | - Пример перегузки функции
    void f(int i) {} |

    int f() {} - !не будет являться перегрузкой функции!
    ** Перегрузкой функции считается только изменение входных парамтеров, а не изменение возвращаемого значения
```
## lambda Функция
    ДОКУМЕНТАЦИЯ: https://javarush.com/groups/posts/lambda-vihrazhenija-v-java-chast-1
```java
    (param1, param2) -> { - создание функции, ей можно заменить только функциональный интерфейс
    ...
    return ... ;
    }

    {FunctionalInterface} name = x -> {return ...} - пример созздания лямбда функции при помощи функционального интерфейса
    * Так как в функциональной мнтерфейсе всегда один метод, то программа знает какую функцию мы представляем в виде лямбда выражения (она знает типы и количество входных параметров, а также возвращаемое значение)

    name.functionName(x); - пример вызова функции для определенного функционального интерфейса
    * functionName(x) - это имя функции, которая была в функциональном интерфейсе
```
# ООП

    Объектно-ориентированное программирование (ООП) - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования

## Принципы ООП

    ДОКУМЕНТАЦИЯ: https://javarush.com/groups/posts/1966-principih-obhhektno-orientirovannogo-programmirovanija

## Инкапсуляция:

    Имеет 2 трактовки:
    1. Инкапсуляция - объединение в одном объекте данных и методов для работы с этими данными
    2. Инкапсуляция - это сокрытие внутреней структуры объекта от внешнего мира. Все изменения состояния объекта происходят при помощи вызовов методов данного объекта

    Данный принцип означает, что объект не должен изменяться ничем, кроме его собстенных методов, это позволяет избежать случайных взаимодействий и изменения полей в процессе работы объекта
    К состоянию объекта имеет доступ только сам объект (состояние объекта - значение всех его полей)
    *Например без инкапсуляции мы могли бы написать Cat.age = -1000;
    Вывод: Необходимо скрывать внутренюю реализацию объекта от внешенго пользователя, стоит давать доступ только к основным методам данного класса

## Наследование:

    Наследование - механизм, который позволяет описать новый класс на основе существующего (родительского). При этом свойства и функциональность родительского класса заимствуются новым классом.

    Наследование является формой отношение "Is a", т.е. одни класс является наследником другого калсса, например, круг является фигурой
    Наследование сужает класс родителя от общего описания до конкретной реализации, все круги являются фигурами, но не все фигуры являются кругами

    Наследование бывет двух типов:
    1. Одиночное наследование, когда один класс наследуется от одного другого
    2. Множественное наследование, когда класс наследуется от нескольких других классов
    * В java множественное наследование разрешено только от определенного типа классов - интерфейсов (#Интерфейсы#)

    Вывод: Наследование приминяется в тех случаях, когда действительно выполнятеся отношение "Is a"(является), т.е. один объект является другим объектом

## Полиморфизм:

    Полиморфизм — это возможность работать с несколькими типами так, будто это один и тот же тип. При этом поведение объектов будет разным в зависимости от типа, к которому они принадлежат.

    Полиморфизм - это возможность одного и того же алгоритма обрабатывать данные разных типов, независимо от того, какие это типы.
    Без проверок типов внутри и ветвления в зависимости от того, с каким конкретным типом алгоритм работает в конкретный момент времени

    Виды полиморфизма:
    1. ad-hoc (Полиморфизм по запросу) - это создание видимости, что алгоритм полиморфный, но на самом деле в момент компиляции программы либо происходит подстановка другого алгоритма, в зависимости от типов переданных аргументов, либо происходит неявное преобразование типаов аргументов.
    * Примером является перегрузка функций/методов.
    2. Параметрический полиморфизм - это возможность алгоритма работать с данными "не названных" типов, которым присвоены абстрактные имена.
    * Примером являются #Generics#: Array<T>
    3. Полиморфизм поддтипов - это возможность алгоритма работать со всеми подтипами одного общего типа, опираясь на свойства общего базового класса. Наследование - это частный случай создания Подтипа
    * Похожей темой является #Восходящее преобразование#

    Польза полиморфизма:
    1. Позволяет уменьшать размер пророгаммы, устранить повторяющийся код

## Абстракция (Дополнительный принцип):

    Абстракция означает выделение главных, наиболее значимых характеристик предмета и наоборот — отбрасывание второстепенных, незначительных.

    Например:
    Скажем, мы создаем картотеку работников компании. Для создания объектов «работник» мы написали класс Employee. Какие характеристики важны для их описания в картотеке компании? ФИО, дата рождения, номер социального страхования, ИНН.
    Но вряд ли в карточке такого типа нам нужны его рост, цвет глаз и волос. Компании эта информация о сотруднике ни к чему.

## Принципы SOLID:

`SOLID` - это аббревеатура, которая описывает пять ключевых принципов проектирования объект-ориентированного кода:
1. `Принцип единой ответственности` (Single Responsibillity). Каждый класс должен выполнять одну поставленную ему задачу. Класс содержит единую логическую связанную функциональность. (Кофемашина только варит кофе, она не занимается кораской заборов)
2. `Принцип Открыто-закрыто` (Open-closed). Класс может предложить возможность расширения функциональности, однако он должен быть закрыт для изменения функцианальности. (Можно добавлять новый функционал, но нельзя изменять старый). Если при добавлении нового функционала необходимо менять исходный код уже написанных методо, то это нарушение метода
3. `Принцип подстановки Барбары Лисков` (Liskov Substitution). Производные классы только расширают функциональность исходного кода, не изменяя ее. Объекты в программе должны быть заменяемы на экземпляры их подтипов без изменения корректности работы. (Мы не можем менять логику работы предков, мы можем ее только дополнять)
4. `Принцип разделения инферфейсов` (Interface Segregation). Не стоит создавать слишком "толстые" интерфейсы. Клиенты не должны зависеть от интерфеса, который они не использую. (в интерфейсе должны быть описаны только методы, которые нужны для выполнения его задачи)
5. `Принцип инверисии зависимостей` (Dependency Inversion). Все зависимости в программе должны поддерживаться за счет абстрактных классов или интерфейсов. (Робот, которые режит пиццу не должен знать, каким инструментом оне режет, он должен просто выполнять работу конертным инструментом, который у него установлен)

## Пакеты и import:
```java
    package [package_name]; - помещает данный класс (файл) в одноименный пакет (задает область видимости класса)
    * Пишется в первой строчке программы
    ** При создании пакета основной файл прогрммы должен хранится по одноименному пути с названием пакета, например, [package_name]/[file_name].java

    Классы, находящиеся в одном пакете могут обращаться друг к другу по короткому имени (file_name)
    Если классы находятся в разных пакетах, то необходимо писать import [package_name].[file_name];
    Для названия пакетов принято называть по доменному имени компании, продукта или проекта, в рамках которых был разработан данный пакет, наприме, com.google.[some_class]

    import [package_name].*; - импортировать все содержимое пакета
    import static [package_name].[file_name]; - такой импорт позволяет обращаться к импортированному объекту без указания класса, например, import static java.lang.Math.sqrt; -> sqrt(4);
    * По большому счету import служит просто для более удобного обращения к другим классам, чтобы не писать их полное имя

    Классы-обертки и другие стандарные классы находятся в пакете java.lang. В каждой программе по умолчанию подразумеваестя import java.lang.*;
```
## Синтаксис class
```java
    [#Модификаторы доступа#] [#Ключевые слова классов#] class [ClassName] { - создание класса

    [#Модификаторы доступа#] [#Ключевые слова переменных#] [#Типы данных#] [name_field] = [val]; - объявление поля класса. Если значение не задано, то будет использоваться значение по умолчанию
    * Для обращения к полям внутри класса необходимо this.[name_field]. Необходимо писать в случае совпадения имен поля и параметров функции, в противном случае спользуется по умолчанию
    * Если у поля указать static final, то поле станет константой

    static int i; |
    static {		  | - данный блок демонстрирует возможность объевить статическую переменную и затем инициализировать ее в статическом блоке
    i = 47;	  | * Данный блок можно использовать без ключевого слова static, для объявления и инициализации нестатических данных
    }				  |

    public ClassName(param1){ - создание конструктора (вызывается через new ClassName([params]))
    this.(param1, [val2]); - вызов одноименного конструктора с другими входными параметрами
    }
    ** Если есть необходимость запретить создавать экземпляры класса, то необходимо поменять модификатор доступа на private

    public ClassName(param1, param2){ - пример написания одноименного контструктора с другими параметрами
    //..
    }

    finalize() {} - данный метод вызывается при удалении объекта данного класса уборщиком мусора. Данный метод необходим, когда экземпляр класса работает с памятью, которую не очистит уборщик мусора

    }
```
## Наследование и Ключевое слово super

    ДОКУМЕНТАЦИЯ: https://javarush.com/groups/posts/1927-konstruktorih-bazovihkh-klassov--
```java
    class [ChildName] extends [ParentName] - наследование одного класса от другого
    * Наследоваться можно только от одного класса
    * При наследовании все поля и методы одного класса переходят к другому классу

    При переопределении методов внутри дочернего класса, ТИП возвращаемого значения должен совпадать или должен являться подклассом возвращаемого класса
    * При выпонении таких условий дочерний класс в себе переопределит метод родительского класса

    При наследовании одного класса от другого сначала вызывается конструктор класса-родителя, а только потом наследника
    * Если в консрукторе класса есть параметры, то необходимо воспользоваться super
    * При создании сложного объекта с множественным наследованием, конструкторы объектов вызываются в следующей последовательности:
    0. Сначала выделяется память под объекты класса и запоняется нулями
    1. Сначала вызывается конструктор базового класса, это повторяется рекурсивно вполоть до Object
    2. Проводится инициализация полей класса в порядке их объявления
    3. Вызывается конструктор производного класса
    *** При переопределении метода базового класса, который вызывается в конструкторе базового класса, будет вызван переопределенный метод
    *** !Единственные методы, которые можно вызывать в конструторе без опаски - это private и final методы!

    super - ссылка на класс, от которого наследовался дочерний класс
    super(param1, param2) - вызов конструктора класса-родителя
    * При данном вызове будут заполнены поля дочернего класса при помощи родителя, это будет актульно только для полей, не переопределенных в дочернем классе
    * Всегда идет перед другим кодом в конструкторе
    ** Если конструктор класса родителя имеет аргументы то вызов super(param1, param2) строго обязателен при инициализации дочернего класса
    super.[name]() - вызов метода родительского класса (работает даже при переопределении метода)
    Наследование не должно противоречить поведению, заданному базовым классом
```

## Класс Object

Класс `Object` в Java **является родительским для всех классов**. Это значит, что каждый класс в Java неявно наследует методы из класса Object, если не указано иное. Рассмотрим методы, определенные в классе Object:

`ДОКУМЕНТАЦИЯ`: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html

### Методы класса Object
```java
    public final Class<?> getClass(); // Возвращает объект класса `Class`, который представляет класс или интерфейс, к которому принадлежит этот объект во время выполнения
    public int hashCode(); // Возвращает хеш код данного объекта (нужно для размещения объектов в хеш таблицах)
    public boolean equals(Object obj); // Сравнивает этот объект с указанным объектом для проверки равенства
    //   * Обязательное требование к реализации: если объекты равны в equals(), то у них должны быть равны hashCode(). Если данное правило нарушается, то эти объекты нельзя хранить в хеш таблицах
    protected Object clone() throws CloneNotSupportedException; // Создает и возвращает копию этого объекта. Для этого метода класс должен реализовать интерфейс `Cloneable`
    public String toString(); // Возвращает строковое представление объекта (по умолчанию это строка типа: [ИмяКласса]@[16-ричный хеш код])
    //  * Если переопределить данный метод в дочерних класса, то он будет вызываться при попытке перевести новый класс в строку
    public final void notify(); // Пробуждает один поток, который ждет на мониторе этого объекта
    public final void notifyAll(); // Пробуждает все потоки, которые ждут на мониторе этого объекта
    public final void wait() throws InterruptedException; // Заставляет текущий поток ожидать, пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта
    public final void wait(long timeout) throws InterruptedException; // Заставляет текущий поток ждать до тех пор, пока не истечет указанный период времени в миллисекундах, если другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта
    public final void wait(long timeout, int nanos) throws InterruptedException; // Заставляет текущий поток ждать до тех пор, пока не истечет указанный период времени в миллисекундах плюс дополнительные наносекунды, если другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта
    protected void finalize() throws Throwable; //  Вызывается сборщиком мусора, когда больше нет ссылок на объект. Обычно используется для освобождения ресурсов перед уничтожением объекта
```
### Реализация `equals` и `hashCode`

Реализация методов `equals` и `hashCode` является важной задачей при создании собственных классов в Java. Эти методы используются, например, в коллекциях, таких как HashMap, HashSet и других. Правильная реализация этих методов позволяет корректно сравнивать объекты и эффективно использовать их в хэш-структурах данных.

#### Основные принципы реализации метода `equals`
1. `Рефлексивность`: для любого ненулевого значения x, x.equals(x) должно возвращать true.
2. `Симметричность`: для любых ненулевых значений x и y, x.equals(y) должно возвращать true тогда и только тогда, когда y.equals(x) также возвращает true.
3. `Транзитивность`: для любых ненулевых значений x, y и z, если x.equals(y) возвращает true и y.equals(z) возвращает true, то x.equals(z) должно также возвращать true.
4. `Согласованност`ь: для любых ненулевых значений x и y, многократные вызовы x.equals(y) должны возвращать одно и то же значение, если только не изменились значения, участвующие в сравнении.
5. `Ненулевое значение`: для любого ненулевого значения x, x.equals(null) должно возвращать false.

#### Основные принципы реализации метода `hashCode`
1. `Согласованность`: если equals двух объектов возвращает true, их hashCode должны быть одинаковыми.
2. `Стабильность`: многократные вызовы метода hashCode на одном и том же объекте должны возвращать одно и то же значение, пока значения объекта не изменяются.

#### Пример реализации `equals` и `hashCode`:
```java
    import java.util.Objects;

    public class Person {
        private int id;
        private String name;
        private int age;

        @Override
        public boolean equals(Object o) {
            if (this == o) return true; // Проверяем, не сравниваем ли мы объект сам с собой (рефлексивность)
            if (o == null || getClass() != o.getClass()) return false; // Проверяем, не является ли сравниваемый объект null и принадлежит ли он тому же классу
            Person person = (Person) o; // Конвертирует объект в нужный нам класс
            return id == person.id && age == person.age && Objects.equals(name, person.name); // Сравниваем значимые поля. В данном случае, поля id, name и age
        }

        @Override
        public int hashCode() {
            return Objects.hash(id, name, age); // Используем метод Objects.hash, который принимает любое количество аргументов и возвращает их хэш-код.
        }
        /* Тонкости и советы:
            Использование полей: Включайте в методы equals и hashCode только те поля, которые определяют уникальность объекта.
            Производительность: Поля, которые часто изменяются, лучше не включать в hashCode, так как это может привести к снижению производительности в коллекциях.
        */
    }
```

## Приведение типов (type casting)

В Java приведение объекта к другому типу (кастинг) работает на основе системы типов и наследования. В строке `Person person = (Person)obj;` происходит так называемое "приведение типов" (type casting), и программа проверяет тип объекта во время выполнения (runtime).

### Пояснение механизма приведения типов

1. `Компиляция и проверка типов`**`:
   - На этапе компиляции компилятор проверяет, является ли приведение типов допустимым. В данном случае, компилятор знает, что `obj` имеет тип `Object`, который является родительским классом для всех объектов в Java, включая `Person`.

2. `Проверка времени выполнения (Runtime check)`:
   - Во время выполнения программы, когда строка `Person person = (Person)obj;` исполняется, Java Virtual Machine (JVM) проверяет фактический тип объекта, на который ссылается `obj`.
   - Если `obj` действительно указывает на объект класса `Person`, приведение типов будет успешным, и переменная `person` будет ссылаться на этот объект. Если объект, на который ссылается `obj`, не является экземпляром `Person` или его подкласса, будет выброшено исключение `ClassCastException`.

### Пример кода приведения типов
```java
    public class Main {
        public static void main(String[] args) {
            Object obj1 = new Person(1, "John", 25); // Переменная `obj1` ссылается на объект класса `Person`
            Object obj2 = new String("Hello"); // Переменная `obj2` ссылается на строку (экземпляр класса `String`)

            // Пример успешного приведения типов
            if (obj1 instanceof Person) { // Проверяет, является ли `obj1` экземпляром класса `Person`
                Person person1 = (Person) obj1; // Приведение типов успешно
                System.out.println(person1.getName()); // John
            }

            // Пример неуспешного приведения типов
            if (obj2 instanceof Person) { //  Проверяет, является ли `obj2` экземпляром класса `Person`
                Person person2 = (Person) obj2; // Приведение типов неудачно, этот код не выполнится
                System.out.println(person2.getName());
            } else {
                System.out.println("obj2 не является экземпляром Person");
            }
        }
    }

    class Person {
        private int id;
        private String name;
        private int age;

        public Person(int id, String name, int age) {
            this.id = id;
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }
    }
```
**Выводы**\
Приведение типов в Java основывается на информации о типах, доступной во время компиляции, и на проверке фактического типа объекта во время выполнения. Использование оператора `instanceof` позволяет безопасно выполнять приведение типов, предотвращая `ClassCastException` и обеспечивая корректную работу программы.

## Ковариантность возвращаемых типов

    Ковариантность типов означает, что переопределенный метод прозводного класса может вернуть тип, производный (является наследником базового типа) от типа, возвращаемого методом базового класса

## Делегирование
```java
    // Делегирование - переадресация некоторого функционала другому классу, без наследования от него
    class SpaceShip {
    SpaceShipControl control = new SpaceShipControl();
    up (int heigth) {
    control.up(); // Пример делегирования функционала другой функции
    }
    }
```
## Перечисления

`ДОКУМЕНТАЦИЯ`: https://javarush.com/groups/posts/1963-kak-ispoljhzovatjh-klass-enum

```java

    public enum [enumName]{ // Перечисления являются классом
    [paramName1] ([param_for_initialization]),
    ...
    [paramNameN] ([param_for_initialization]); // Перечисление занчений, это эквивалентно public static final paramNameN = [enumName]([param_for_initialization]);

    // Объявление полей и методов, как в обычном классе
    private String title; // Объявление поля значения для paramName1
    [enumName](String title) { // Создание конструктора для инициализации
    this.title = title;
    }
    }

    public enum [enumName] { // Пример создания перчисления, при этом каждому значению будет присвоено численое значение (ZERO.ordinal() = 0, ONE.ordinal() = 1, ...)
    ZERO, ONE, TWO
    }
    enumName zero = enumName.ZERO; // Получение значения из перечисления

    enumName[] paramArray = enumName.values(); // Возвращает массив перечисления в том же порядке
    String paramName = paramName1.name(); // Возвращает имя элемента как в исходном коде
    int paramNumber = paramName1.ordinal(); // Возвращает номер элемента в последовательсности объявлений, начиная с 0
```
## Интерфейсы

    ДОКУМЕНТАЦИЯ: https://javarush.com/groups/posts/1981-dlja-chego-v-java-nuzhnih-interfeysih
```java
    public interface [InterfaceName] { - объявление интерфейса, при наследовании от которого мы обязаны реализовать все методы и поля из данного интерфейса
    ... - тут объявляются поля и методы, но БЕЗ РЕАЛИЗАЦИИ
    int CONST = [VAL]; - пример объявления поля интерфейса, оно всегда должно быть проинициализировано
    int CONST_2 = sum(1, 2); - пример инициализации поля в зависимосит от результата функции
    int div(int a, int b); - пример объявления функции sum с возвращаемым типом данных и параметрами

    default void print(String str) {...} - пример объявления функции с реализацией по умолчанию (если функция не была переопределена в дочерних классах)
    }
    * Все методы интерфейса публичные и абстрактные (public, abstract) (писать данные модификаторы не обязательно)
    * Все поля интерфейса публичные, статические, финальные (public, static, final) (по сути константы)

    class [ClassName] implements [InterfaceName1], [InterfaceName2], ... {} - наследование класса от интерфейса
    * Можно наследоваться от любого количества интерфейсов
    * Класс может как наследоваться от других классов, так и от интерфейсов одновременно

    !При определении методов интерфеса они ОБЯЗАТЕЛЬНО должны быть public
    Интерфейсы можно писать как тип данных в параметрах функции, при пердаче типа данных в функцию будет применено восходящее преобразование
    **Интерфейсы могут наследоваться от дргуих интерфейсов, для этого после объявления интерфейса пишется extends [InterfaceName1], [InterfaceName2] (НЕ implements).
    При подобном наследовании нет необходимости писать повторно методы наследуемых интерфейсов, только новые.
```
## Функциональные интерфейсы - интерфейсы, которые имеют один абстрактный метод, который можно переопределить
```java
    @FunctionalInterface - специальная аннотация, которая позволяет понять компилятору, кто интерфейс функциональный
    * При этом дефолтные методы и ститические методы не идут в счет

    Встроенные функциональные интерфейсы: https://metanit.com/java/tutorial/9.3.php

    Predicate<T> - проверяет соблюдение некоторого условия. Если оно соблюдается, то возвращается значение true.
    public interface Predicate<T> {
    boolean test(T t);
    }
    Consumer<T> - выполняет некоторое действие над объектом типа T, при этом ничего не возвращая
    public interface Consumer<T> {
    void accept(T t);
    }
    Function<T,R> - представляет функцию перехода от объекта типа T к объекту типа R
    public interface Function<T, R> {
    R apply(T t);
    }
    Supplier<T> - не принимает никаких аргументов, но должен возвращать объект типа T
    public interface Supplier<T> {
    T get();
    }
    UnaryOperator<T> - принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T
    public interface UnaryOperator<T> {
    T apply(T t);
    }
    BinaryOperator<T> - принимает в качестве параметра два объекта типа T, выполняет над ними бинарную операцию и возвращает ее результат также в виде объекта типа T
    public interface BinaryOperator<T> {
    T apply(T t1, T t2);
    }
    ** !!!Функциональные интерфейсы нужны чтобы реализовывать #lambda Функция#!!!

    Функциональные интерфейсы: https://javarush.com/groups/posts/2866-funkcionaljhnihe-interfeysih-v-java
```
## Аннотации
```java
    Для методов

    @Deprecated /** Тут пишется, что лучше использовать вместо него*/- означает, что класс или метод устарел и не рекомендуется к использованию
    public static ...

    @SuppressWarnings("[disabledValue]") - временно отключает предупреждения компилятора на подозрительные места в коде. Отключаемое значение указывается в параметре аннотации
    public static ...

    @Override - данная аннотация показывает, что мы хотим переопределить метод, который был в родительском классе
    * Если переопределение не будет происходить, то компилятор укажет на проблемы

    Для интерфейсов

    @FunctionalInterface - означает, что данный интерфейс реализует 1 абстрактный метод
    * При этом дефолтные методы и ститические методы не идут в счет

    Для переменных

    @Nullable String nullText = null; - означает, что данная переменная может принять значение null
    @NonNull  String notNullText = "Hi"; - означает, что данная переменная не может принять значение null
```
## Обработка ошибок
```java
    throw new [класс исключения] ([Текст сообщения]) // вызов определенной ошибки с текстом сообщения

    Классификация исключений:
    1. Исключения JVM - возникают при компиляции программы
    2. Возникающие в пользовательском коде:
    - #Проверяемые# - означает, что JVM следит в каком месте они вызываются и они не могут быть вызваны просто так (компилятор требует их декларировать и обрабатывать)
    * Данные исключения принадлежат к классу Exception
    - Непроверяемые - ошибки такого типа могут вызываться везде
    * Данные иключения принадлежат к классу RuntimeException

    Если мы хотим создать свое исключение, то необходимо создать класс, который наследуется от Exception или RuntimeException (в зависимости от того, какой тип сключения нам нужен)

    try { ... } // блок кода, где могут появляться ошибки
    catch (ExceptionСlass1 | ExceptionСlass2 e) {
    e.getMessage(); - показать только сообщение об ошибке
    e.printSrackTrace(); - вывести стек вызовов
    } // блок, обработки ошибки
    catch (ExceptionСlass3 ignore) {} // Возможность игнорировать ошибку
    finally {...} // блок, который всегда выполнится после try-catch; (Обычно данный блок используют для освобождения памяти)

    try c ресурсами:

    try (Resource r1 = new Resource(); Resource r2 = new Resource();...){...} // октрытие блока catch с ресурсами
    * Особенностью данной контсрукции является то, что при завершении работы блоков будет автоматически вызвана команда r1.close(), r2.close() ...
    ** Ресурсом является любой класс, который реализует интерфейс AutoCloseable, т.е. имеет команду close()
```
## Логирование
```java
    import java.util.logging.*; - импорт библиотеки логгера

    private static final Logger LOGGER = Logger.getLogger(ClassName.class.getName()); - стандартное создание логгера для текущего класса
    * В качетстве имя логгера передается имя текущего класса

    Запись логов

    LOGGER.log(Level.INFO, "[Text]"); - запись лога
    * Уровни:
    SEVERE - на данном уровне логируются серьезные ошибки программы (ужас ужас)
    WARNING - логируются предупреждения
    INFO - просто информация
    CONFIG - логирование конфигурационных параметров
    FINE   |
    FINER  | - для детального логирования, что программа делает
    FINEST |

    LOGGER.warning("[Text]"); - у логгера есть возможность показывать сообщения в консоль определенного уровня
    * Для каждого уровня есть одноименный метод
    LOGGER.setLeval(Level.[level]); - установить для логгера уровень, чтобы сообщения более низких уровней игнорировались
    * По у молчанию стоит уровень INFO

    LOGGER.log(Level.[level], "{0}", [param]); - сопособ подстановки ОДНОГО параметра в строку сообщения
    LOGGER.log(Level.[level], "{0} {1}", new Object[] {param1, param2}); - способ подстановки нескольких параметров в строку
    LOGGER.log(Level.[level], "[Text]", e); - способ передачи ошибки при логировании

    Обработчики сообщения - определяе, куда будет записано сообщение

    java.until.logging.ConsoleHandler - Выводит в консоль
    java.until.logging.FileHandler - Выводит в файл
    java.until.logging.SocketHandler - Отправляет по сети

    LOGGER.addHandler([handler]); - добавление хендлера к логгеру

    Форматы вывода - определяет в каком формате сообщения записываются в лог

    java.until.logging.SimpleFormatter - формат записи в виде текста
    java.until.logging.XMLFormatter - формат записи в виде XML файла

    * Формат определяется у хендлера:
    Handler handler; - объявление
    handler.setFormatter([formatter]); - определения формата записи
    handler.setLevel(Level.[level]); - определения уровня

    logging.properties - файл, который можно создать в проекте на уровне папки src, в котором можно прописать конфигурацию логирования по умолчанию
    * Пример:
    .level=ALL - разрешает видеть записи на всех уровнях
    .handler=java.until.logging.ConsoleHandler - определение обработчика
    .java.until.logging.ConsoleHandler.level=ALL - определение уровня обработчика
    ** Чтобы запустить программу с настройками логирования через файл, необходимо при запуске программы передать параметр:
    -Djava.until.logging.config.file=logging.properties
```
## Работа с файловой системой
```java
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.nio.file.Files;
    import java.io.File - класс, который отечает за работу с файлами
    // * Немного устареший класс

    // ДОКУМЕНТАЦИЯ: https://javarush.com/groups/posts/2275-files-path

    File javaFile = new File("[Path]"); // создание экземпляра файла через передачу пути конструктору
    // * Адрес директории или файла может записываться по разному, в зависимости от системы:
    Windows: "C:\\dir1\\bin\\java.java"
    Unix: "usr/bin/ls"
    // * В объявлении пути к файлу можно использовать как абсолютный так и относительные пути

    File.separator // содержит символ для разделения адреса (зависит от операционной системы, например в Windows = "\\")
    File.separatorChar // тоже самое, что и File.separator, только не типа String, а Char

    File.pathSeparator // содержит символ для разделения набора путей (зависит от операционной системы, например Windows = ";")
    File.pathSeparatorChar // тоже самое, что и File.pathSeparator, только не типа String, а Char

    javaFile.isAbsolute(); // проверяет, задан ли путь к файлу абсолютным путем
    javaFile.getAbsolutePath(); // получить абсолютный путь для файла

    javaFile.getPath(); // получить полный адрес файла ("C:\\dir1\\bin\\java.java")
    javaFile.getName(); // получить имя файла ("java.java")
    javaFile.getParent(); // получить путь до директории с файлом ("C:\\dir1\\bin")

    javaFile.getCanonicalPath(); // привести путь файла к конаническому виду, т.е. получить релальный путь до файла (без учета ссылок с система)
    // * Если привести пути 2//х файлов к каноническому виду, то можно сравнить их как строки и понять один и тот же это файл или нет

    javaFile.exists(); // проверяет, существует ли файл
    javaFile.isFile(); // проверяет, является ли файл именно файлом
    javaFile.isDirectory(); // проверяет, является ли файл директорией

    javaFile.length(); // возвращает размер файла в байтах
    javaFile.lastModified(); // возвращает время последнеего изменения в миллисекундах с 1970 года
    // * Если файла не существует то данный методы будут возвращать 0

    javaFile.list(); // возвращает массив строк файлов данной директории (если файл директория)
    javaFile.listFiles(); // возвращает массив файлов данной директории (если файл директория)
    // * Если директории не существует, то вернется null

    javaFile.createNewFile(); // создает файл в системе, по указанному адресу (адрес указывается при инициализации)
    // * Если файл создан, то возвращает true, если файл уже существует, то false
    // * Может выбрасить #Проверяемые# ошибку (IOException), поэтому ее нужно указать в имени функции через throws IOException
    javaFile.mkdir(); // создает директорию (только 1)
    javaFile.mkdirs(); // создает структуру из директорий (любого размера)

    javaFile.delete(); // удаляет данный файл или директорию(она должна быть пуста)

    java.nio.file.Path // класс, который отечает за работу с файлами
    // * Более современная версия, которая бросает исключения при ошибке работы с файлами

    Path path = Paths.get("[Path]"); // объявление пути к файлу
    File fromPath = path.toFile(); // конвертировать путь в файл
    Path fromFile = javaFile.toPath(); // конвертировать файл в путь

    Path java = Paths.get("[Path]"); // пример создания пути к файлу
    java.isAbsolute(); // проверяет, задан ли путь к файлу абсолютным путем
    java.getFileName(); // возвращает имя файла
    java.getParent(); // получить путь до директории, где хранится файл
    java.getNameCount(); // возвращает количество компонентов пути
    java.getName([idx]); // получить имя компонента пути по индексу
    java.startWith("[Path]"); // проверка на то, начинается ли путь с заданного пути

    Files.move(Path sourcePath, Path destinationPath, StandardCopyOption.REPLACE_EXISTING); // Перемещение файла
    Files.exists(java); // проверка сущетсвования файла по данному пути
    Files.size(java); // возвращает размер файла в байтах
    Files.getLastModifiedTime(java).toMillis(); // возвращает время последнеего изменения в миллисекундах с 1970 года
    Files.copy(java, Paths.get("[newPath]"), [option]); // копирует файл в указанную директорию
    // * Набор опций содержится в классе StandardCopyOption:
    StandardCopyOption.REPLACE_EXISTING // опция, которая отвечает за замену файла при копировании, если одноименный файл уже существует
    Files.createDirectoriy(path); // создает директорию (только 1)
    Files.createDirectories(path); // создает структуру из директорий (любого размера)
```
## Ввод и вывод данных

`java.io.InputStream` - базовый абстрактный класс, который обеспечивает поток байт, из которых можно читать и информацию
`java.io.OutputStream` - базовый абстрактный класс, который обеспечивает поток байт, в который можно записывать информацию

В Java классы `FileInputStream` и `FileOutputStream` используются для чтения и записи данных из файлов в байтовом формате. Эти классы являются частью пакета `java.io` и позволяют работать с файлами на низком уровне.

### FileInputStream

#### Описание
`FileInputStream` используется для чтения байтов из файла. Он наследует класс `InputStream` и предоставляет методы для чтения данных из файла.

#### Основные методы
``` java
int read() // Читает один байт данных из входного потока. Возвращает данных в виде целого числа от 0 до 255. Возвращает -1, если достигнут  файла.
int read(byte[] b) // Читает байты из потока и помещает их в массив `b`. ащает количество прочитанных байтов или -1, если достигнут конец файла.
int read(byte[] b, int off, int len)//  Читает до `len` байтов из потока ещает их в массив `b`, начиная с смещения `off`. Возвращает количество танных байтов или -1, если достигнут конец файла.
void close() // Закрывает поток и освобождает все системные ресурсы, связанные с этим потоком.
```

### java.io.Reader

`java.io.Reader` - отвечает за чтение потока символов (абстрактный класс)

#### Основные методы
```java
    int read() throws IOException // Читает один символ и возвращает его в виде целого числа. Возвращает -1, если достигнут конец потока
    int read(char[] cbuf) throws IOException // Читает символы в массив cbuf и возвращает количество фактически прочитанных символов. Возвращает -1, если достигнут конец потока.
    int read(char[] cbuf, int offset, int length) throws IOException // Читает до length символов в массив cbuf, начиная с позиции offset. Возвращает количество фактически прочитанных символов или -1, если достигнут конец потока.
    long skip(long n) throws IOException // Пропускает n символов в потоке. Возвращает количество фактически пропущенных символов.
    boolean ready() throws IOException // Проверяет, готов ли поток для чтения без блокировки. Возвращает true, если поток готов, иначе false.
    boolean markSupported() // Проверяет, поддерживает ли поток операцию mark (отметку). Возвращает true, если поддерживает, иначе false.
    void mark(int readAheadLimit) throws IOException // Помечает текущую позицию в потоке, чтобы можно было вернуться к ней позже с помощью метода reset. Параметр readAheadLimit определяет, сколько символов можно прочитать перед тем, как отметка станет недействительной.
    void reset() throws IOException // Возвращает поток к позиции, отмеченной последним вызовом метода mark
    void close() throws IOException // Закрывает поток и освобождает все связанные с ним ресурсы.
```

### InputStreamReader

`InputStreamReader` Преобразует байтовые потоки (InputStream) в символьные потоки (Reader). Поддерживает указание кодировки для чтения данных. Является наследником для [Reader](#javaioreader) и реализует его методы.

#### Констркуторы
```java
    InputStreamReader fileReader = new InputStreamReader(new FileInputStream("in.txt"), StandardCharset.UTF_8); // Пример инициализации InputStreamReader

    InputStreamReader(InputStream in) // Создает InputStreamReader, использующий кодировку по умолчанию.
    InputStreamReader(InputStream in, String charsetName) // Создает InputStreamReader, использующий указанную кодировку.
    InputStreamReader(InputStream in, Charset charset) // Создает InputStreamReader, использующий указанный объект Charset.
    InputStreamReader(InputStream in, CharsetDecoder dec) // Создает InputStreamReader, использующий указанный CharsetDecoder.

    OutputStreamWriter fileWriter = new OutputStreamWriter(new FileInputStream("in.txt"), StandardCharset.UTF_8); |
```

### FileReader

Класс `FileReader` наследует все методы от класса [InputStreamReader](#inputstreamreader), а также от его родителя [Reader](#javaioreader). Вот основные методы, которые можно использовать с объектами FileReader:

Особенности FileReader:
- Предназначен для чтения текстовых файлов.
- Автоматически использует кодировку по умолчанию для вашей системы (обычно UTF-8).
- Подходит для простых случаев чтения текстовых файлов, но не предоставляет буферизацию.

#### Конструкторы
```java
    FileReader(String fileName) // Создает объект FileReader, который будет читать из файла с указанным именем
    FileReader(File file) // Создает объект FileReader, который будет читать из указанного объекта File
    FileReader(FileDescriptor fd) // Создает объект FileReader, который будет читать из указанного дескриптора файла
```

### BufferedReader

`BufferedReader` в Java - это класс, который добавляет буферизацию к потоку символов, что значительно улучшает производительность при чтении данных из источника, такого как файл или сеть. Буферизация помогает уменьшить количество операций ввода-вывода, группируя их в более крупные блоки, что делает чтение данных более эффективным.

#### Конструкторы

```java
    BufferedReader(Reader in) // Создает буферизированный поток чтения с буфером по умолчанию (8192 символов)
    BufferedReader(Reader in, int sz) // Создает буферизированный поток чтения с указанным размером буфера
    BufferedReader(InputStreamReader in) // Создает буферизированный поток чтения для InputStreamReader

    // Пример
    BufferedReader reader = new BufferedReader(new FileReader("example.txt"));
    BufferedReader reader = new BufferedReader(new FileReader("example.txt"), 16384);
```

`BufferedReader` наследует методы класса [Reader](#javaioreader) и добавляет свои собственные:

```java
    String line = reader.readLine(); // Читает одну строку текста. Возвращает null, если достигнут конец потока
```

#### Как работает буферизация в BufferedReader

Буферизация в классе `BufferedReader` используется для повышения производительности при чтении данных из символьных потоков, таких как файлы или сетевые соединения. Буферизация помогает уменьшить количество операций ввода-вывода (I/O), которые могут быть медленными и ресурсоемкими, за счет чтения больших блоков данных за один раз и сохранения их во внутреннем буфере для последующего использования.

1. **Инициализация буфера**:
   - При создании объекта `BufferedReader` создается внутренний буфер фиксированного размера (по умолчанию 8192 символа или 8 КБ). Размер буфера можно изменить, передав нужное значение в конструктор.

2. **Чтение данных в буфер**:
   - Когда вы вызываете метод `read` или `readLine` на `BufferedReader`, он сначала проверяет, есть ли данные в буфере. Если буфер пуст, `BufferedReader` считывает большой блок данных из исходного потока (например, файла) и заполняет буфер.
   - Это чтение большого блока данных вместо отдельных символов или строк значительно снижает количество обращений к исходному потоку.

3. **Обслуживание запросов из буфера**:
   - После заполнения буфера данные читаются из него до тех пор, пока он не опустеет. Это означает, что последующие вызовы методов `read` или `readLine` могут обрабатываться быстро, так как данные уже находятся в памяти и не требуется выполнение операций I/O.
   - Когда буфер опустеет, `BufferedReader` снова считывает следующий блок данных из исходного потока и заполняет буфер.

### Методы BufferedReader и их работа с буфером

1. **String readLine()**:
   - Читает одну строку текста, завершающуюся символом новой строки (`\n`), возвратом каретки (`\r`) или их комбинацией (`\r\n`).
   - Если строка полностью находится в буфере, она извлекается и возвращается.
   - Если строка пересекает границу буфера, `BufferedReader` считывает дополнительные данные в буфер, чтобы завершить чтение строки.

2. **int read()**:
   - Читает один символ из буфера и возвращает его в виде целого числа.
   - Если буфер пуст, `BufferedReader` заполняет его, считывая данные из исходного потока.

3. **int read(char[] cbuf, int off, int len)**:
   - Читает до `len` символов в массив `cbuf`, начиная с позиции `off`.
   - Если запрашиваемые данные находятся в буфере, они извлекаются из него.
   - Если запрашиваемые данные превышают размер оставшегося буфера, `BufferedReader` заполняет буфер дополнительными данными и продолжает чтение.

#### Заключение

Буферизация в `BufferedReader` значительно улучшает производительность ввода-вывода, уменьшая количество операций чтения из основного источника данных. Это достигается за счет использования внутреннего буфера, который позволяет считывать большие блоки данных за один раз и обслуживать последующие запросы из памяти, а не из исходного потока. Это делает `BufferedReader` особенно полезным для работы с текстовыми файлами и другими символьными потоками, где частое чтение данных может быть накладным.

### FileOutputStream

#### Описание
`FileOutputStream` используется для записи байтов в файл. Он наследует класс `OutputStream` и предоставляет методы для записи данных в файл.

#### Основные методы
```java
void write(int b) // Записывает один байт данных, указанный аргументом `b`, в выходной поток.
void write(byte[] b) // Записывает массив байтов `b` в выходной поток.
void write(byte[] b, int off, int len) // Записывает `len` байтов из массива `b`, начиная с смещения `off`, в выходной поток.
void close() // Закрывает поток и освобождает все системные ресурсы, связанные с этим потоком.
```

### java.io.Writer

`java.io.Writer` - отвечает за вывод данных в потоке символов (абстрактный класс)

#### Основные методы
```java
    void write(int c) throws IOException // Записывает один символ
    void write(char[] cbuf) throws IOException // Записывает массив символов cbuf
    void write(char[] cbuf, int offset, int length) throws IOException // Записывает часть массива символов cbuf, начиная с позиции offset до количества символов length
    void write(String str) throws IOException // Записывает строку str
    void write(String str, int offset, int length) throws IOException // Записывает часть строки str, начиная с позиции offset до количества символов length
    void flush() throws IOException // Очищает буфер и записывает все буферизованные данные в целевой поток
    void close() throws IOException // Закрывает поток и освобождает все связанные с ним ресурсы
```

### OutputStreamWriter

`OutputStreamWriter` в Java - это класс, который преобразует символьные потоки в байтовые потоки, используя указанную кодировку. Он является мостом между потоками символов (Writer) и потоками байтов (OutputStream). Является наследником для [Writer](#javaiowriter) и реализует его методы.

#### Констркуторы

```java

    OutputStreamWriter(OutputStream out); // Создает OutputStreamWriter, используя кодировку по умолчанию
    OutputStreamWriter(OutputStream out, String charsetName); // Создает OutputStreamWriter с указанной кодировкой
    OutputStreamWriter(OutputStream out, Charset charset):; // Создает OutputStreamWriter с указанным объектом Charset
    CharsetEncoder encoder = StandardCharsets.UTF_8.newEncoder();
    OutputStreamWriter(OutputStream out, CharsetEncoder encoder); // Создает OutputStreamWriter с указанным CharsetEncoder
```

### FileWriter

`FileWriter` в Java - это класс, который используется для записи символьных данных в файл. Он является подклассом класса [OutputStreamWriter](#outputstreamwriter) и предназначен для упрощения записи в файлы. FileWriter работает с файлами, используя кодировку по умолчанию для системы.

#### Конструкторы

```java
   FileWriter(String fileName) // Создает объект FileWriter, который записывает в файл с указанным именем. Если файл существует, он будет перезаписан
   FileWriter(String fileName, boolean append) // Создает объект FileWriter, который записывает в файл с указанным именем. Если append равно true, данные будут добавлены в конец файла, если файл существует
   FileWriter(File file) // Создает объект FileWriter, который записывает в указанный объект File. Если файл существует, он будет перезаписан
   FileWriter(File file, boolean append) // Создает объект FileWriter, который записывает в указанный объект File. Если append равно true, данные будут добавлены в конец файла, если файл существует
   FileWriter(FileDescriptor fd) // Создает объект FileWriter, который записывает в указанный дескриптор файла.
```

### BufferedWriter

`BufferedWriter` в Java - это класс, который добавляет буферизацию к символьному потоку для более эффективной записи данных. Буферизация позволяет уменьшить количество операций ввода-вывода (I/O), которые являются относительно медленными и ресурсоемкими, за счет группировки нескольких операций записи в одну крупную операцию.

#### Конструкторы
```java
BufferedWriter(Writer out) // Создает BufferedWriter с буфером по умолчанию (8192 символов).
BufferedWriter(Writer out, int sz) // Создает BufferedWriter с указанным размером буфера.
```

`BufferedWriter` наследует методы класса [Writer](#javaiowriter) и добавляет свои собственные:
```java
    void newLine() // Записывает символ(ы) новой строки. Этот метод обеспечивает переносимость, так как символы новой строки зависят от платформы.
```

## Работа с URL

Класс `URL` в Java представляет собой унифицированный указатель ресурса (URL), который является ссылкой на ресурс в Интернете. Этот класс находится в пакете java.net и позволяет работать с URL-адресами, предоставляя методы для их анализа и использования.

Класс `URL` в Java представляет собой унифицированный указатель ресурса (URL), который является ссылкой на ресурс в Интернете. Этот класс находится в пакете `java.net` и позволяет работать с URL-адресами, предоставляя методы для их анализа и использования.

### Описание основных методов класса URL
Класс `URL` в Java предоставляет несколько конструкторов для создания URL-объектов. Каждый из этих конструкторов принимает разные параметры, которые представляют собой различные части URL. Давайте рассмотрим эти конструкторы и параметры подробнее.

### Конструкторы класса URL

#### 1. Конструктор `URL(String spec)`
Этот конструктор принимает строку `spec`, которая представляет собой полный URL-адрес в виде строки.

```java
URL url = new URL("https://www.example.com:8080/path/to/resource?query=java#section");
```

- **spec**: Полная спецификация URL в виде строки, включая протокол, хост, порт (необязательно), путь, строку запроса (необязательно) и якорь (необязательно).

#### 2. Конструктор `URL(String protocol, String host, int port, String file)`
Этот конструктор позволяет создавать URL-объект из отдельных компонентов: протокол, хост, порт и файл (путь).

```java
URL url = new URL("https", "www.example.com", 8080, "/path/to/resource?query=java#section");
```

- **protocol**: Протокол URL (например, "http", "https", "ftp").
- **host**: Хост URL, доменное имя или IP-адрес (например, "www.example.com").
- **port**: Порт URL (например, 80 для HTTP, 443 для HTTPS). Если порт не указан, используйте -1.
- **file**: Путь к ресурсу, включая строку запроса и якорь (например, "/path/to/resource?query=java#section").

#### 3. Конструктор `URL(String protocol, String host, String file)`
Этот конструктор похож на предыдущий, но без указания порта. По умолчанию используется порт по умолчанию для указанного протокола (например, 80 для HTTP, 443 для HTTPS).

```java
URL url = new URL("https", "www.example.com", "/path/to/resource?query=java#section");
```

- **protocol**: Протокол URL.
- **host**: Хост URL.
- **file**: Путь к ресурсу, включая строку запроса и якорь.

#### 4. Конструктор `URL(URL context, String spec)`
Этот конструктор позволяет создавать URL-объект на основе базового URL (контекста) и относительной спецификации URL.

```java
URL base = new URL("https://www.example.com/path/to/");
URL url = new URL(base, "resource?query=java#section");
```

- **context**: Базовый URL, относительно которого будет интерпретироваться `spec`.
- **spec**: Спецификация URL, которая может быть полной или относительной. Если она относительная, она будет интерпретироваться относительно `context`.

### Методы для получения частей URL
``` java
    URL url = new URL("https://www.example.com:8080/path/to/resource?query=java#section");
    url.getProtocol(); // Возвращает протокол URL (Output: https)
    url.getHost(); // Возвращает хост URL. (Output: www.example.com)
    url.getPort(); // Возвращает порт URL или -1, если порт не указан. (Output: 8080)
    url.getPath(); // Возвращает путь URL. (Output: /path/to/resource)
    url.getQuery(); // Возвращает строку запроса URL или null, если запрос отсутствует. (Output: query=java)
    url.getRef() // Возвращает якорь (реф) URL или null, если якорь отсутствует. (Output: section)
    url.getFile() // Возвращает строку файла URL (путь и запрос). (Output: /path/to/resource?query=java)
```
### Методы для работы с соединением
```java
    openStream(); // Открывает соединение и возвращает `InputStream` для чтения данных из ресурса.
    try {
        URL url = new URL("https://www.example.com");
        try (InputStream in = url.openStream();
                Scanner scanner = new Scanner(in)) {
            // ...
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
    
    openConnection(); // Возвращает объект `URLConnection` для более детального управления соединением.
    try {
        URL url = new URL("https://www.example.com");
        URLConnection connection = url.openConnection();
        try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
            // ...
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
```

### HttpURLConnection

`HttpURLConnection` является подклассом URLConnection, который используется для управления HTTP соединениями. Он предоставляет дополнительные методы для настройки и работы с HTTP-запросами и ответами.

#### Методы настройки запроса:

```java
    URL url = new URL("https://jsonplaceholder.typicode.com/posts");
    HttpURLConnection connection = (HttpURLConnection) url.openConnection(); // Открывает связь к ресурсу

    connection.setRequestMethod(String method); // Этот метод устанавливает HTTP-метод для запроса, который может быть одним из следующих: "GET", "POST", "PUT", "DELETE", "HEAD", "OPTIONS", "TRACE".
    connection.setRequestProperty(String key, String value); //  устанавливает значение определенного заголовка запроса. Это может быть полезно для установки заголовков, таких как "Content-Type", "User-Agent", "Accept", и других. (Например, connection.setRequestProperty("User-Agent", "Mozilla/5.0"))
    connection.setDoOutput(boolean doOutput); // Указывает, будет ли использоваться поток вывода (необходимо для методов "POST" и "PUT").

    connection.disconnect(); // Закрывает соединение и освобождает все связанные ресурсы.
```

#### Методы отправки данных:
```java
    URL url = new URL("https://jsonplaceholder.typicode.com/posts");
    HttpURLConnection connection = (HttpURLConnection) url.openConnection();

    try (OutputStream os = connection.getOutputStream()) { // Возвращает поток вывода, через который можно отправлять данные на сервер.
        byte[] input = data.getBytes("utf-8");
        os.write(input, 0, input.length);
    }
```

#### Методы чтения ответа:
```java
    URL url = new URL("https://jsonplaceholder.typicode.com/posts");
    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
    
    getInputStream(); // Возвращает поток ввода для чтения данных из ответа сервера.
    try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
        String inputLine;
        StringBuilder response = new StringBuilder();
        while ((inputLine = in.readLine()) != null) {
            response.append(inputLine);
        }
        System.out.println(response.toString());
    }    
    
   int responseCode = connection.getResponseCode(); //  Возвращает код ответа HTTP от сервера.
    getResponseMessage(): Возвращает сообщение ответа HTTP.
```

### Пример использования класса URL

```java
import java.net.URL;
import java.net.MalformedURLException;
import java.io.InputStream;
import java.io.IOException;
import java.util.Scanner;

public class URLExample {
    public static void main(String[] args) {
        try {
            // Создание объекта URL
            URL url = new URL("https://www.example.com:80/path/to/resource?query=java#section");

            // Получение различных частей URL
            System.out.println("Protocol: " + url.getProtocol());
            System.out.println("Host: " + url.getHost());
            System.out.println("Port: " + url.getPort());
            System.out.println("Path: " + url.getPath());
            System.out.println("Query: " + url.getQuery());
            System.out.println("Ref: " + url.getRef());

            // Открытие соединения и чтение данных
            try (InputStream in = url.openStream();
                 Scanner scanner = new Scanner(in)) {
                System.out.println("Content:");
                while (scanner.hasNextLine()) {
                    System.out.println(scanner.nextLine());
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
    }
}
```

### Пример использования openConnection()

```java
import java.net.URL;
import java.net.HttpURLConnection;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class URLConnectionExample {
    public static void main(String[] args) {
        try {
            // Создание объекта URL
            URL url = new URL("https://www.example.com");

            // Открытие соединения
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod("GET");

            // Получение кода ответа
            int responseCode = connection.getResponseCode();
            System.out.println("Response Code: " + responseCode);

            // Чтение данных из ответа
            try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
                String inputLine;
                StringBuilder content = new StringBuilder();
                while ((inputLine = in.readLine()) != null) {
                    content.append(inputLine);
                }
                System.out.println("Content: " + content.toString());
            } catch (IOException e) {
                e.printStackTrace();
            }

            // Закрытие соединения
            connection.disconnect();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### Описание

1. **Создание URL-объекта**:
   - Создаем объект `URL` с заданным URL-адресом.

2. **Открытие соединения**:
   - Открываем соединение с использованием `openConnection()` и приводим его к `HttpURLConnection`.
   - Устанавливаем метод запроса `GET`.

3. **Получение ответа**:
   - Получаем код ответа сервера с помощью `getResponseCode()`.
   - Читаем данные из входного потока соединения с использованием `BufferedReader`.

4. **Закрытие соединения**:
   - Закрываем соединение с помощью `disconnect()`.

Класс `URL` является мощным инструментом для работы с URL-адресами и соединениями в Java, предоставляя высокоуровневый интерфейс для взаимодействия с интернет-ресурсами.

## Generics
Generics - позволяют параметризовать функцию - добавить параметр, который можно использовать в функции (при этом параметр должен удволетворять какому то условию)<br> ДОКУМЕНТАЦИЯ: https://javarush.com/groups/posts/2004-teorija-dzhenerikov-v-java-ili-gde-na-praktike-stavitjh-skobki
```java
    ** В параметризации могут искользоваться только #Ссылочные типы#:
    * Если не указать параметр при инициализации, то будет подставлен Object

    Параметризованные классы

    public class [ClassName]<T extends ClassOrInterfaceName & InterfaceName & ... > {...} - код создания параметризованного класса
    * <T> - название параметра
    * extends позволяет установить ограничения на тип параметра
    ** Параметр исопльзуется вместо типа данных данных:
    public T get(); - T указывает на тип возвращаемого значения функции
    ** Статические методы параметризовать нельзя
    Пример объявления параметризованного класса:
    ClassName<String> ex = new ClassName<>();

    Ограничения

    Пример: <T extends Number> - значит, что в качетсве параметра могут передаваться только переменные с типом Number

    Wildcard
    ДОКУМЕНТАЦИЯ: https://docs.oracle.com/javase/tutorial/java/generics/unboundedWildcards.html

    <?> - тип неограниченного подстановочного знака, означает неизвесный тип
    <? super T>
    * По сути мы смотрим, чтобы ? был родителем от типа T
    ** Нужно использовать, когда мы отдаем данные куда то
    <? extends T> - означает, что мы принимаем любой тип подтипа T (так, например Integer является подтипом Number)
    * По сути мы смотрим, чтобы ? был наследником от типа T
    ** Нужно использовать, когда мы получаем данные от куда то
```
# Коллекции

**Что такое коллекции?** \
В Java коллекции представляют собой наборы объектов, которые могут храниться, управляться и манипулироваться в виде единой структуры данных. Коллекции предоставляют более гибкие и мощные механизмы для работы с группами объектов по сравнению с массивами.

**Зачем нужны коллекции?** \
Коллекции нужны для упрощения работы с группами объектов. Они предоставляют методы для добавления, удаления, поиска и итерации по элементам, что делает управление данными проще и эффективнее. Также они позволяют использовать различные алгоритмы и структуры данных, такие как списки, множества, очереди и карты.

Основные интерфейсы коллекций
В Java существует несколько ключевых интерфейсов для работы с коллекциями:

1. `Collection`: Базовый интерфейс для всех коллекций.
2. `List`: Упорядоченная коллекция, допускающая дубликаты. Примеры: ArrayList, LinkedList.
3. `Set`: Коллекция, не допускающая дубликатов. Примеры: HashSet, TreeSet.
4. `Queue`: Коллекция, представляющая очередь. Примеры: LinkedList, PriorityQueue.
5. `Map`: Коллекция, состоящая из пар ключ-значение. Примеры: HashMap, TreeMap.

## Collection

Collection -  базовый интерфейс для других коллекций

`ДОКУМЕНТАЦИЯ`: [Collection](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Collection.html)

### Основные методы Collection

```java
    Collection<Type> collection = ... ; // пример объявления коллекции

    // Осноные методы Collection:
    collection.size(); // возвращает размер коллекции
    collection.isEmpty(); // проверяет пустой ли список
    collection.contains(Object o); // проверка принадлежности коллекции
    collection.add([Object]); // добавление элемента к коллекции (возвращает boolean, который указывает изменилась коллекция или нет)
    collection.remove(Object o); // удаление элемента (возвращает boolean, который указывает изменилась коллекция или нет)
    collection.clear(); // очистить коллекцию

    // Collection реализует интерфейс Iterable, который имеет следующие методы:
    void forEach(Consumer<? super T> action) // Метод forEach принимает в качестве аргумента объект, реализующий функциональный интерфейс Consumer. Этот интерфейс содержит единственный метод accept, который выполняется для каждого элемента коллекции.
    collection.forEach(element -> System.out.println(element)); // Используем forEach с лямбда-выражением
    collection.forEach(System.out::println); // Используем forEach со ссылкой на метод (тоже реализация интерфейса Consumer)
    // * forEach не может менять значения, она работает с копиями данных. Однако она может менять изменяемые объекты (например, экземпляры классов):
    collection.forEach(person -> person.age += 1); // Изменение значения поля через forEach

    Iterator<Type> it = collection.iterator(); // преобразует коллекцию в итерируемы объект
    // * Итератор нужно использовать для изменения элементов коллекции
    it.hasNext(); // проверка на существание следующего элемента
    it.next(); // получение следующего элемента
    it.remove(); // удаляет текущий элемент из коллекции

    Spliterator<Type> sit = collection.spliterator(); // Этот метод возвращает объект типа Spliterator, который можно использовать для разделения элементов коллекции для параллельной обработки.
    sit.tryAdvance(Consumer<? super T> action); // Если есть еще элементы для обработки, выполняет действие action на следующем элементе и возвращает true.
    sit.trySplit(); // Попытка разделить текущий Spliterator на два. Возвращает новый Spliterator, который охватывает часть элементов, или null, если разделение невозможно.
    sit.estimateSize(); // Оценивает количество оставшихся элементов для обработки. Если количество элементов не известно, возвращает Long.MAX_VALUE.
    sit.characteristics(); // Возвращает битовую маску характеристик этого Spliterator. Возможные характеристики:
        // * ORDERED: элементы имеют определенный порядок.
        // * DISTINCT: элементы уникальны.
        // * SORTED: элементы отсортированы.
        // * SIZED: известно точное количество элементов.
        // * NONNULL: элементы не содержат null.
        // * IMMUTABLE: элементы неизменяемы.
        // * CONCURRENT: поддерживается параллельная модификация.
        // * SUBSIZED: все разделенные Spliterator имеют известный размер.

```
## List

Интерфейс `List` в Java является частью коллекционного фреймворка и представляет собой упорядоченную коллекцию, которая допускает дубликаты. Элементы в списке упорядочены в определенной последовательности, и доступ к ним осуществляется с использованием индексов.

`ДОКУМЕНТАЦИЯ`: [List](https://docs.oracle.com/javase/8/docs/api/java/util/List.html) 

Интерфейс `List` расширяет интерфейс [Collection](#collection)

### Основные методы List

```java
    import java.util.List; // импорт интерфейса List

    List<Type> list = new ArrayList<>();

    list.get([idx]); // получение элемента по индексу
    list.set([idx], value); // изменить элемент по индексу
    list.add([idx], value); // добавить элемент в указанное место
    list.remove([idx]); // удалить элемент по индексу
    list.indexOf(Object o); // поиск элемента по его содержанию (возвращает первый индекс)
    list.lastIndexOf(Object o); // поиск элемента по его содержанию (возвращает последний индекс)
    list.sublist([fromIndex],[toIndex]); // возвращает часть списка по его индексам
    * Возвращает новый элемент List<E>, !однако списки остаются связанными!
    * Позволяет реализовывать новый функционал:
    list.sublist(1, 2).clear(); // очистить часть списка
    list.sublist(1, 2).indexOf("foo"); // найти индекс элемента по значению в указанном отрезке
    list.equals(list1); // сравнение списков по содержимому
    Object[] objectArr = list.toArray(); // перевод списка в массив объектов
    Type[] typeArr = list.toArray(new Type[list.size()]); // перевод списка в массив объектов определенного типа

    // Полезные функции

    import java.util.Collections; // импорт класса Collections;

    Collections.shuffle(list); // перемешать список
    Collections.sort(list); // сортирует указанный список
    Collections.unmodifiableSet(originalSet); // возвращает обертку для данного класса, которая запрещает вносить изменения в получившийся объект
    // * Может быть применени и к другим коллекциям, например:
    unmodifiableList() // к List
    unmodifiableMap() // к Map
```

### Реализации List

Интерфейс `List` в Java имеет несколько реализаций, каждая из которых имеет свои особенности, преимущества и ограничения. Основные реализации включают `ArrayList`, `LinkedList`, `Vector` и `CopyOnWriteArrayList`. Рассмотрим каждую из них подробно.

### 1. `ArrayList`

#### Описание

`ArrayList` — это реализация `List`, основанная на массиве. Она предоставляет динамически изменяемый массив, который автоматически расширяется по мере добавления элементов.

#### Особенности

- **Скорость доступа**: Быстрый доступ к элементам по индексу (O(1)).
- **Вставка и удаление**: Медленные операции вставки и удаления, особенно в середине списка (O(n)), так как элементы сдвигаются.
- **Ресурсоемкость**: Требует больше памяти, чем фактически необходимо, из-за внутреннего массива, который часто выделяется с запасом.

#### Методы

`ArrayList` не добавляет новых методов к интерфейсу `List`, но предоставляет высокоэффективную реализацию методов `get`, `set`, `add`, и `remove`.

#### Применение

- Подходит для случаев, когда основная операция — это доступ к элементам по индексу.
- Идеален для чтения данных и редкого обновления.

### 2. `LinkedList`

#### Описание

`LinkedList` — это реализация `List`, основанная на двусвязном списке. Каждый элемент списка содержит ссылку на предыдущий и следующий элементы.

#### Особенности

- **Скорость доступа**: Медленный доступ к элементам по индексу (O(n)).
- **Вставка и удаление**: Быстрые операции вставки и удаления (O(1)), если известно местоположение узла.
- **Ресурсоемкость**: Использует больше памяти на каждый элемент из-за хранения ссылок.

#### Методы

`LinkedList` добавляет методы из интерфейса `Deque`, так как реализует 2 интерфейса:
``` java
    void addFirst(E e); // Вставляет элемент в начало списка.
    void addLast(E e); // Вставляет элемент в конец списка.
    E getFirst(); // Возвращает первый элемент списка.
    E getLast(); // Возвращает последний элемент списка.
    E removeFirst(); // Удаляет и возвращает первый элемент списка.
    E removeLast(); // Удаляет и возвращает последний элемент списка.
```

#### Применение

- Подходит для случаев, когда часто выполняются операции вставки и удаления.
- Идеален для реализации очередей и стеков.

### 3. `Vector`

#### Описание

`Vector` — это синхронизированная реализация `List`, основанная на массиве. Это устаревшая версия динамического массива, введенная в ранних версиях Java.

#### Особенности

- **Скорость доступа**: Быстрый доступ к элементам по индексу (O(1)).
- **Вставка и удаление**: Медленные операции вставки и удаления (O(n)).
- **Синхронизация**: Все методы синхронизированы, что делает его безопасным для многопоточного использования, но добавляет оверхед.

#### Методы

`Vector` добавляет несколько методов:
``` java
    void addElement(E obj); // Добавляет элемент в конец вектора.
    int capacity(); // Возвращает текущую емкость вектора.
    void ensureCapacity(int minCapacity); // Увеличивает емкость вектора, если она меньше указанной.
```
#### Применение

- Подходит для многопоточных сред, где требуется синхронизированный доступ к элементам.
- В современных приложениях рекомендуется использовать `ArrayList` с ручной синхронизацией.

### 4. `CopyOnWriteArrayList`

#### Описание

`CopyOnWriteArrayList` — это реализация `List`, предназначенная для многопоточного доступа. Каждый раз, когда в список вносятся изменения, создается новая копия массива.

#### Особенности

- **Скорость доступа**: Быстрый доступ к элементам по индексу (O(1)).
- **Вставка и удаление**: Медленные операции вставки и удаления (O(n)), так как создается копия массива.
- **Синхронизация**: Обеспечивает безопасный доступ для чтения без необходимости внешней синхронизации.

#### Методы

`CopyOnWriteArrayList` не добавляет новых методов, но изменяет поведение существующих для обеспечения безопасного многопоточного доступа.

#### Применение

- Подходит для случаев, когда операции чтения значительно преобладают над операциями записи.
- Идеален для реализации неизменяемых коллекций в многопоточных средах.

```java
    List<Type> list = new ArrayList<>(Arrays.asList(array)); // объявление списка на базе массива
    * Arrays.asList(array) - позволяет перевести какой то массив в List
    ** Можно передавать в любой экземпляр класса Collection
    * Также можно написать начения через запятую: ... new ArrayList<>(1,2,3,4,5);

    List<Type> list = new LinkedList<>(); - объявление списка, основанного на двусвязном списке
    * Позволяет эффективно добавлять и удалять элементы в начале или конце списка
    * Доступ по индексу не такой эффективный
```

## Queue

Интерфейс `Queue` в Java представляет собой коллекцию, предназначенную для хранения элементов, которые обрабатываются в определенном порядке. Обычно очереди следуют принципу FIFO (First-In-First-Out)

Интерфейс Queue расширяет интерфейс [Collection](#collection) и добавляет методы для вставки, извлечения и просмотра элементов. Все эти методы могут быть разделены на два основных набора: методы, которые бросают исключения при неудаче, и методы, которые возвращают специальное значение (или null) при неудаче.

`ДОКУМЕНТАЦИЯ`: [Queue](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Queue.html)

### Основные методы Queue

```java
    import java.util.LinkedList;
    import java.util.Queue;
    Queue<Type> queue = new LinkedList<>();

    queue.add(element); - добавляет элемент в хвост очереди (если не удается добавить элемент из-за ограничения по размеру, например, то будет выдано исключение)
    queue.offer(element); - добавляет элемент в хвост очереди (если не удается добавить элемент из-за ограничения по размеру, например, то будет возвращен false)

    queue.remove(); - извлекают первый элемент из головы очереди (если извлечь не получается, то кидает ошибку)
    queue.poll(); - извлекают первый элемент из головы очереди (если извлечь не получается, то возвращает null)

    queue.element(); - позволяет получить элемент из головы очереди, но не удалаять его (если извлечь не получается, то кидает ошибку)
    queue.peek();- позволяет получить элемент из головы очереди, но не удалаять его (если извлечь не получается, то возвращает null)
```
### Реализации Queue

Интерфейс `Queue` в Java имеет несколько реализаций, каждая из которых предназначена для различных сценариев использования и имеет свои особенности. Основные реализации включают `LinkedList`, `PriorityQueue`, `ArrayDeque`, а также многопоточные реализации из пакета `java.util.concurrent`. Рассмотрим каждую из них подробно.

### 1. `LinkedList`

#### Описание

`LinkedList` реализует интерфейсы `List`, `Deque`, и `Queue`. Эта реализация основана на двусвязном списке.

#### Особенности

- **Доступ и изменение**: Быстрое добавление и удаление элементов с начала и конца списка.
- **Память**: Использует больше памяти на элемент по сравнению с массивами из-за хранения ссылок.

#### Методы

`LinkedList` добавляет методы из интерфейса `Deque`, такие как `addFirst`, `addLast`, `removeFirst`, `removeLast`, `getFirst`, `getLast`.

#### Применение

- Подходит для реализации очередей FIFO и двусторонних очередей.
- Идеален для частых операций добавления и удаления элементов с начала и конца списка.

### 2. `PriorityQueue`

#### Описание

`PriorityQueue` реализует приоритетную очередь на основе бинарной кучи. Элементы очереди извлекаются в порядке их приоритета.

#### Особенности

- **Приоритет**: Элементы с наивысшим приоритетом извлекаются первыми.
- **Сортировка**: Элементы упорядочиваются в соответствии с их естественным порядком или компаратором, заданным при создании очереди.

#### Методы

`PriorityQueue` не добавляет новых методов к интерфейсу `Queue`, но изменяет поведение методов `add`, `offer`, `poll`, и `remove` в соответствии с приоритетом элементов.

#### Применение

- Подходит для задач, где элементы должны обрабатываться в порядке приоритета.
- Идеален для алгоритмов, таких как алгоритм Дейкстры для нахождения кратчайшего пути.

#### Примеры

**Пример 1: Использование с естественным порядком**
```java
    import java.util.PriorityQueue;
    PriorityQueue<Integer> pq = new PriorityQueue<>();

    pq.add(10); pq.add(20); pq.add(15);

    // Извлечение элементов в порядке приоритета
    System.out.println(pq.poll()); // 10
    System.out.println(pq.poll()); // 15
    System.out.println(pq.poll()); // 20
```
**Пример 2: Использование с компаратором**
```java
    import java.util.PriorityQueue;
    Comparator<String> lengthComparator = (s1, s2) -> Integer.compare(s1.length(), s2.length());
    PriorityQueue<String> pq = new PriorityQueue<>(lengthComparator);

    pq.add("apple"); pq.add("banana"); pq.add("cherry");

    // Извлечение элементов в порядке длины строк
    System.out.println(pq.poll()); // apple
    System.out.println(pq.poll()); // cherry
    System.out.println(pq.poll()); // banana
```
**Пример 3: Реализация задачи с приоритетами**\
Предположим, у нас есть класс Task с полем priority, и мы хотим управлять задачами в очереди с приоритетом.
```java
    import java.util.PriorityQueue;

    class Task implements Comparable<Task> {
        private String name;
        private int priority;

        public Task(String name, int priority) {
            this.name = name;
            this.priority = priority;
        }

        @Override
        public int compareTo(Task other) {
            return Integer.compare(this.priority, other.priority);
        }
    }
    // ...
    PriorityQueue<Task> taskQueue = new PriorityQueue<>();

    taskQueue.add(new Task("Write code", 2));
    taskQueue.add(new Task("Debug code", 1));
    taskQueue.add(new Task("Test code", 3));

    while (!taskQueue.isEmpty()) {
        System.out.println("Processing task: " + taskQueue.poll());
    }
```

### 3. `ArrayDeque`

#### Описание

`ArrayDeque` реализует интерфейсы `Deque` и `Queue` и основан на массиве, который автоматически увеличивается по мере необходимости.

#### Особенности

- **Производительность**: Быстрая амортизированная вставка и удаление элементов с начала и конца.
- **Память**: Меньше накладных расходов по сравнению с `LinkedList`.

#### Методы

`ArrayDeque` добавляет методы из интерфейса `Deque`, такие как `addFirst`, `addLast`, `removeFirst`, `removeLast`, `getFirst`, `getLast`.

#### Применение

- Подходит для реализации стеков и очередей FIFO.
- Идеален для многопоточных сред благодаря отсутствию синхронизации.

### 4. `ConcurrentLinkedQueue`

#### Описание

`ConcurrentLinkedQueue` — это многопоточная неблокирующая очередь, основанная на алгоритме Майкла-Скотта (Michael-Scott).

#### Особенности

- **Безопасность для многопоточности**: Реализация не требует внешней синхронизации.
- **Производительность**: Высокая производительность в многопоточных средах.

#### Методы

`ConcurrentLinkedQueue` не добавляет новых методов к интерфейсу `Queue`, но все методы безопасны для использования несколькими потоками.

#### Применение

- Подходит для многопоточных приложений, где требуется неблокирующий доступ к очереди.
- Идеален для реализации пула задач.

### 5. `LinkedBlockingQueue`

#### Описание

`LinkedBlockingQueue` — это блокирующая очередь, основанная на связном списке. Очередь поддерживает лимит на максимальный размер.

#### Особенности

- **Блокировка**: Поддержка блокирующих операций `put` и `take`.
- **Память**: Использует больше памяти на элемент по сравнению с массивами.

#### Методы

`LinkedBlockingQueue` добавляет методы:

```java
boolean offer(E e, long timeout, TimeUnit unit) // Вставляет элемент, ожидая свободного места в течение указанного времени.
E poll(long timeout, TimeUnit unit) // Извлекает и удаляет элемент, ожидая появления элемента в течение указанного времени.
void put(E e) // Вставляет элемент, ожидая свободного места.
E take() // Извлекает и удаляет элемент, ожидая появления элемента.
```

#### Применение

- Подходит для многопоточных приложений, где требуется блокирующий доступ к очереди.
- Идеален для реализации производственных потоков и потребителей.

### 6. `ArrayBlockingQueue`

#### Описание

`ArrayBlockingQueue` — это блокирующая очередь, основанная на массиве фиксированного размера.

#### Особенности

- **Фиксированный размер**: Размер очереди задается при создании и не может изменяться.
- **Блокировка**: Поддержка блокирующих операций `put` и `take`.

#### Методы

Методы аналогичны `LinkedBlockingQueue`.

#### Применение

- Подходит для многопоточных приложений, где требуется блокирующий доступ к очереди с фиксированным размером.
- Идеален для задач, требующих фиксированного количества элементов в очереди.

### 7. `PriorityBlockingQueue`

#### Описание

`PriorityBlockingQueue` — это блокирующая версия `PriorityQueue`, основанная на бинарной куче.

#### Особенности

- **Приоритет**: Элементы обрабатываются в порядке приоритета.
- **Блокировка**: Поддержка блокирующих операций.

#### Методы

Методы аналогичны `PriorityQueue`, но добавляются блокирующие операции.

#### Применение

- Подходит для многопоточных приложений, где элементы должны обрабатываться в порядке приоритета.
- Идеален для задач, требующих приоритетного выполнения.

### 8. `SynchronousQueue`

#### Описание

`SynchronousQueue` — это блокирующая очередь, в которой каждая операция вставки должна ждать соответствующую операцию удаления и наоборот.

#### Особенности

- **Без буфера**: Элементы передаются напрямую между потоками.
- **Блокировка**: Поддержка блокирующих операций.

#### Методы

Методы аналогичны другим блокирующим очередям, но каждая операция вставки блокируется до тех пор, пока не будет выполнена соответствующая операция удаления.

#### Применение

- Подходит для многопоточных приложений, где требуется непосредственная передача данных между потоками.
- Идеален для задач, требующих синхронной передачи данных.

## Deque

Интерфейс `Deque` (Double-Ended Queue) в Java представляет собой двустороннюю очередь, которая поддерживает вставку и удаление элементов с обеих сторон. Этот интерфейс расширяет интерфейс [Queue](#queue) и предоставляет дополнительные методы для работы с элементами на обоих концах очереди.

`ДОКУМЕНТАЦИЯ`: [Deque](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Deque.html)

### Основные методы Deque

```java
    Deque<Type> deque = new ArrayDeque<>(); // способ создания дека на базе массива
    Deque<Type> deque1 = new LinkedList<>(); // способ создания дека на базе двусвязанного списка

    // Методы для работы с первым элементом

    void deque.addFirst(E e) // Вставляет элемент в начало очереди. Бросает исключение `IllegalStateException`, если очередь ограничена по размеру и переполнена.
    boolean deque.offerFirst(E e) // Вставляет элемент в начало очереди. Возвращает `true`, если вставка успешна, иначе возвращает `false`.
    E deque.removeFirst() // Удаляет и возвращает первый элемент из очереди. Бросает исключение `NoSuchElementException`, если очередь пуста.
    E deque.pollFirst() // Удаляет и возвращает первый элемент из очереди. Возвращает `null`, если очередь пуста.
    E deque.getFirst() // Возвращает первый элемент из очереди без удаления. Бросает исключение `NoSuchElementException`, если очередь пуста.
    E deque.peekFirst() // Возвращает первый элемент из очереди без удаления. Возвращает `null`, если очередь пуста.

    // Методы для работы с последним элементом

    void deque.addLast(E e) // Вставляет элемент в конец очереди. Бросает исключение `IllegalStateException`, если очередь ограничена по размеру и переполнена.
    boolean deque.offerLast(E e) // Вставляет элемент в конец очереди. Возвращает `true`, если вставка успешна, иначе возвращает `false`.
    E deque.removeLast() // Удаляет и возвращает последний элемент из очереди. Бросает исключение `NoSuchElementException`, если очередь пуста.
    E deque.pollLast() // Удаляет и возвращает последний элемент из очереди. Возвращает `null`, если очередь пуста.
    E deque.getLast() // Возвращает последний элемент из очереди без удаления. Бросает исключение `NoSuchElementException`, если очередь пуста.
    E deque.peekLast() // Возвращает последний элемент из очереди без удаления. Возвращает `null`, если очередь пуста.

    // Методы для работы со стэком

    void deque.push(E e) // Вставляет элемент в начало очереди (эквивалентно `addFirst`).
    E deque.pop() // Удаляет и возвращает первый элемент из очереди (эквивалентно `removeFirst`).

    // Методы для удаления элементов

    boolean deque.removeFirstOccurrence(Object o) // Удаляет первое вхождение указанного элемента из очереди.
    boolean deque.removeLastOccurrence(Object o) // Удаляет последнее вхождение указанного элемента из очереди.
```

### Реализации Deque

Интерфейс `Deque` в Java имеет несколько реализаций, каждая из которых предназначена для различных сценариев использования и имеет свои особенности. Основные реализации включают `ArrayDeque`, `LinkedList`, и многопоточные реализации из пакета `java.util.concurrent`, такие как `ConcurrentLinkedDeque` и `LinkedBlockingDeque`. Рассмотрим каждую из них подробно.

### 1. `ArrayDeque`

#### Описание

`ArrayDeque` реализует интерфейсы `Deque` и `Queue` и основан на массиве, который автоматически увеличивается по мере необходимости.

#### Особенности

- **Производительность**: Быстрая амортизированная вставка и удаление элементов с начала и конца.
- **Память**: Меньше накладных расходов по сравнению с `LinkedList`, так как не требуется дополнительная память для хранения ссылок на элементы.
- **Нет синхронизации**: Не является потокобезопасной.

#### Методы

`ArrayDeque` не добавляет новых методов к интерфейсу `Deque`, но реализует все методы `Deque` эффективно благодаря внутреннему использованию массива.

#### Применение

- Подходит для реализации стеков и очередей FIFO.
- Идеален для однопоточных сред, где требуется быстрая вставка и удаление элементов.

### 2. `LinkedList`

#### Описание

`LinkedList` реализует интерфейсы `List`, `Deque`, и `Queue`. Эта реализация основана на двусвязном списке.

#### Особенности

- **Производительность**: Быстрая вставка и удаление элементов с начала и конца.
- **Память**: Использует больше памяти на элемент по сравнению с массивами из-за хранения ссылок.
- **Гибкость**: Может быть использован как список, очередь или стек.

#### Методы

`LinkedList` добавляет методы из интерфейса `Deque`, такие как `addFirst`, `addLast`, `removeFirst`, `removeLast`, `getFirst`, `getLast`.

#### Применение

- Подходит для задач, требующих частых операций добавления и удаления элементов с начала и конца.
- Идеален для реализации двусторонних очередей и стеков.

### 3. `ConcurrentLinkedDeque`

#### Описание

`ConcurrentLinkedDeque` — это неблокирующая многопоточная реализация интерфейса `Deque` на основе алгоритма Майкла-Скотта.

#### Особенности

- **Производительность**: Высокая производительность в многопоточных средах.
- **Безопасность для многопоточности**: Реализация не требует внешней синхронизации.
- **Память**: Использует больше памяти на элемент по сравнению с массивами из-за хранения ссылок.

#### Методы

`ConcurrentLinkedDeque` не добавляет новых методов к интерфейсу `Deque`, но все методы безопасны для использования несколькими потоками.

#### Применение

- Подходит для многопоточных приложений, где требуется неблокирующий доступ к двусторонней очереди.
- Идеален для задач, требующих высокопроизводительного многопоточного доступа.

### 4. `LinkedBlockingDeque`

#### Описание

`LinkedBlockingDeque` — это блокирующая двусторонняя очередь, основанная на двусвязном списке. Очередь поддерживает лимит на максимальный размер.

#### Особенности

- **Блокировка**: Поддержка блокирующих операций `put` и `take`.
- **Память**: Использует больше памяти на элемент по сравнению с массивами.
- **Производительность**: Потокобезопасна благодаря блокировкам.

#### Методы

`LinkedBlockingDeque` добавляет методы:
```java
boolean offerFirst(E e, long timeout, TimeUnit unit) //  Вставляет элемент в начало очереди, ожидая свободного места в течение указанного времени.
boolean offerLast(E e, long timeout, TimeUnit unit) //  Вставляет элемент в конец очереди, ожидая свободного места в течение указанного времени.
E pollFirst(long timeout, TimeUnit unit) //  Извлекает и удаляет первый элемент из очереди, ожидая появления элемента в течение указанного времени.
E pollLast(long timeout, TimeUnit unit) //  Извлекает и удаляет последний элемент из очереди, ожидая появления элемента в течение указанного времени.
void putFirst(E e) //  Вставляет элемент в начало очереди, ожидая свободного места.
void putLast(E e) //  Вставляет элемент в конец очереди, ожидая свободного места.
E takeFirst() //  Извлекает и удаляет первый элемент из очереди, ожидая появления элемента.
E takeLast() //  Извлекает и удаляет последний элемент из очереди, ожидая появления элемента.
```

#### Применение

- Подходит для многопоточных приложений, где требуется блокирующий доступ к двусторонней очереди.
- Идеален для задач, требующих синхронной передачи данных между потоками.

## Set

Интерфейс `Set` в Java представляет собой коллекцию, которая не допускает дублирующихся элементов. Этот интерфейс расширяет интерфейс [Collection](#collection) и определяет поведение коллекций, в которых каждое значение может встречаться только один раз.

Порядок элементов не гарантирован.

`ДОКУМЕНТАЦИЯ`: [Set](https://docs.oracle.com/javase/8/docs/api/java/util/Set.html)

### Основные методы Set

Так как `Set` расширяет интерфейс `Collection`, он наследует все методы `Collection`. Однако, некоторые методы из `Collection` имеют специфическое поведение для `Set`.

```java
    import java.util.Set;

    Set<Type> set = new HashSet<>(); // способ создания множества при помощи хеш таблиц
    // ** Для данной реализации очень важно согласование equals() и hashCode() (a.equals(b) => a.hashCode() == b.hashCode())
    // * При переборе элементов они будут возвращаться в случаном порядке (по значению hashCode элементов)
    Set<Type> set = new LinkedHashSet<>(); // способ создания множества
    // * При переборе элементов они будут возвращаться в порядке добавления во множество

    // Методы для добавления элементов

    boolean set.add(E e) //  Добавляет элемент в набор, если он еще не присутствует. Возвращает `true`, если элемент был добавлен (то есть он не был в наборе ранее), и `false`, если элемент уже был в наборе.

    // Методы для удаления элементов

    boolean set.remove(Object o) //  Удаляет элемент из набора, если он присутствует. Возвращает `true`, если элемент был удален, и `false`, если элемент не был найден в наборе.
    void set.clear() //  Удаляет все элементы из набора.

    // Методы для проверки наличия элементов

    boolean set.contains(Object o) //  Проверяет, содержится ли указанный элемент в наборе. Возвращает `true`, если элемент присутствует в наборе, и `false` в противном случае.

    // Методы для размерности и пустоты

    int set.size() //  Возвращает количество элементов в наборе.
    boolean set.isEmpty() //  Проверяет, пуст ли набор. Возвращает `true`, если набор пуст, и `false` в противном случае.

    // Методы для итерации

    Iterator<E> set.iterator() //  Возвращает итератор, который позволяет обходить элементы набора.

    // Методы для операций с другими коллекциями

    boolean set.addAll(Collection<? extends E> c) //  Добавляет все элементы из указанной коллекции в набор. Возвращает `true`, если набор был изменен в результате этой операции (то есть, если хотя бы один элемент из коллекции не был ранее в наборе).
    boolean set.containsAll(Collection<?> c) //  Проверяет, содержатся ли все элементы указанной коллекции в наборе.
    boolean set.removeAll(Collection<?> c) //  Удаляет из набора все его элементы, которые содержатся в указанной коллекции. Возвращает `true`, если набор был изменен в результате этой операции.
    boolean set.retainAll(Collection<?> c) //  Удаляет из набора все элементы, которые не содержатся в указанной коллекции. Возвращает `true`, если набор был изменен в результате этой операции.

    SortedSet<Type> sortedSet = new TreeSet<>(); // создание отсартированного множества при помощи бинарного дерева поиска

    sortedSet.subSet(fromElement, toElement); // возвращает элементы множетсва, которые принадлежат данному промежутку
    sortedSet.headSet(toElement); // возвращает элементы множетсва, которые меньше данного элемента
    sortedSet.tailSet(toElement); // возвращает элементы множетсва, которые больше данного элемента
    // * Все методы возвращают не копию множества, а его чать (т.е. они связаны)
    sortedSet.first(); // возвращает первый элемент множетсва
    sortedSet.last(); // возвращает последний элемент множетсва
```

### Реализации Set

Интерфейс `Set` в Java имеет несколько ключевых реализаций, каждая из которых имеет свои особенности и подходит для различных сценариев использования. Основные реализации включают `HashSet`, `LinkedHashSet`, `TreeSet`, и многопоточные реализации из пакета `java.util.concurrent`, такие как `ConcurrentSkipListSet` и `CopyOnWriteArraySet`. Давайте рассмотрим каждую из них подробно.

### 1. `HashSet`

#### Описание

`HashSet` — это самая простая и широко используемая реализация интерфейса `Set`, основанная на хэш-таблице.

#### Особенности

- **Производительность**: Быстрое добавление, удаление и проверка наличия элемента (в среднем O(1)).
- **Порядок**: Не гарантирует порядок элементов.
- **Дополнительные методы**: Не добавляет дополнительных методов.

#### Применение

- Подходит для случаев, когда требуется быстрая производительность и нет необходимости в упорядоченности элементов.
- Идеален для хранения уникальных элементов без необходимости в определенном порядке.

### 2. `LinkedHashSet`

#### Описание

`LinkedHashSet` расширяет `HashSet` и использует связный список для поддержания порядка вставки элементов.

#### Особенности

- **Производительность**: Быстрое добавление, удаление и проверка наличия элемента (в среднем O(1)), немного медленнее, чем `HashSet`, из-за поддержания порядка вставки.
- **Порядок**: Гарантирует сохранение порядка вставки элементов.
- **Дополнительные методы**: Не добавляет дополнительных методов.

#### Применение

- Подходит для случаев, когда требуется сохранение порядка вставки элементов.
- Идеален для приложений, где важен порядок элементов наряду с уникальностью.

### 3. `TreeSet`

#### Описание

`TreeSet` реализует интерфейсы `NavigableSet` и `SortedSet` и основан на красно-черном дереве.

#### Особенности

- **Производительность**: Добавление, удаление и проверка наличия элемента имеют логарифмическое время выполнения (O(log n)).
- **Порядок**: Гарантирует упорядоченность элементов по их естественному порядку или по предоставленному компаратору.
- **Дополнительные методы**: Добавляет методы из `NavigableSet` и `SortedSet`.

#### Применение

- Подходит для случаев, когда требуется упорядоченность элементов и логарифмическое время выполнения операций.
- Идеален для задач, требующих диапазонных запросов и сортированных наборов данных.

### 4. `ConcurrentSkipListSet`

#### Описание

`ConcurrentSkipListSet` — это потокобезопасная реализация `NavigableSet`, основанная на алгоритме skip list (пропускной список).

#### Особенности

- **Производительность**: Добавление, удаление и проверка наличия элемента имеют логарифмическое время выполнения (O(log n)).
- **Порядок**: Гарантирует упорядоченность элементов по их естественному порядку или по предоставленному компаратору.
- **Потокобезопасность**: Все методы безопасны для многопоточного использования.
- **Дополнительные методы**: Добавляет методы из `NavigableSet` и `SortedSet`.

#### Применение

- Подходит для многопоточных приложений, где требуется упорядоченность элементов.
- Идеален для задач, требующих потокобезопасного доступа к сортированным наборам данных.

### 5. `CopyOnWriteArraySet`

#### Описание

`CopyOnWriteArraySet` — это потокобезопасная реализация `Set`, основанная на механизме копирования при записи.

#### Особенности

- **Производительность**: Быстрое чтение элементов (O(1)), медленные операции записи (O(n)), так как при каждой модификации создается копия внутреннего массива.
- **Порядок**: Гарантирует сохранение порядка вставки элементов.
- **Потокобезопасность**: Все методы безопасны для многопоточного использования.
- **Дополнительные методы**: Не добавляет дополнительных методов.

#### Применение

- Подходит для многопоточных приложений, где операции чтения значительно преобладают над операциями записи.
- Идеален для неизменяемых наборов данных и сценариев, где частые изменения не требуются.

## Map

Интерфейс `Map` в Java представляет собой коллекцию, которая связывает ключи с соответствующими значениями. Карта не может содержать дублирующихся ключей, и каждый ключ может быть связан с не более чем одним значением.
* Позволяет индексировать элементы другими объектами

`ДОКУМЕНТАЦИЯ`: [Map](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Map.html)

### Основные методы Map

```java
    import java.util.Map;

    Map<TypeKey, TypeValue> hashMap = new HashMap<>();
    Map<TypeKey, TypeValue> linkedMap = new LinkedHashMap<>();
    Map<TypeKey, TypeValue> treeMap = new TreeMap<>();
    * Отличия данных вариаций аналогичны отличиям подобных в методе Set
        
    // Методы для работы с элементами

    V map.put(K key, V value); // Вставляет указанное значение, связанное с указанным ключом, в карту. Если карта ранее содержала значение для этого ключа, старое значение заменяется.
    V map.get(Object key); // Возвращает значение, связанное с указанным ключом, или `null`, если карта не содержит такого ключа.
    V map.remove(Object key); // Удаляет отображение для указанного ключа, если оно присутствует.
    boolean map.containsKey(Object key); // Возвращает `true`, если карта содержит отображение для указанного ключа.
    boolean map.containsValue(Object value); // Возвращает `true`, если карта содержит одно или несколько значений, которые равны указанному значению.
    int map.size(); // Возвращает количество отображений ключей в этой карте.
    boolean map.isEmpty(); // Возвращает `true`, если карта не содержит отображений ключей.
    void map.clear(); // Удаляет все отображения из этой карты.

    // Методы для получения представлений карты

    Set<K> map.keySet(); // Возвращает множество ключей, содержащихся в этой карте.
    Collection<V> map.values(); // Возвращает коллекцию значений, содержащихся в этой карте.
    Set<Map.Entry<K, V>> map.entrySet(); // Возвращает множество отображений ключ-значение, содержащихся в этой карте.
        // * Возвращает объект Map.Entry<A,B>, который имеет 2 метода: getKey() и getValue()
    
    // Дополнительные методы

    V map.putIfAbsent(K key, V value); //  (Java 8): Вставляет значение, связанное с указанным ключом, если ключ отсутствует в карте или связан с `null`.
    boolean map.remove(Object key, Object value); //  (Java 8): Удаляет отображение для ключа только в том случае, если оно связано с указанным значением.
    boolean map.replace(K key, V oldValue, V newValue); //  (Java 8):Заменяет значение, связанное с указанным ключом, только в том случае, если оно в настоящее время связано с указанным значением.
    V map.replace(K key, V value); //  (Java 8): Заменяет значение, связанное с указанным ключом, только в том случае, если ключ уже связан с некоторым значением.
    void map.forEach(BiConsumer<? super K, ? super V> action); //  (Java 8): Выполняет указанное действие для каждой пары ключ-значение в карте.
    void map.replaceAll(BiFunction<? super K, ? super V, ? extends V> function); //  (Java 8): Заменяет каждое значение в карте результатом применения указанной функции к его текущему значению.
```

### Реализации Map

Интерфейс `Map` в Java имеет несколько ключевых реализаций, каждая из которых обладает своими особенностями и подходит для различных сценариев использования. Основные реализации включают `HashMap`, `LinkedHashMap`, `TreeMap`, и многопоточные реализации из пакета `java.util.concurrent`, такие как `ConcurrentHashMap`. Рассмотрим каждую из них подробно.

### 1. `HashMap`

#### Описание

`HashMap` — это самая распространенная и широко используемая реализация интерфейса `Map`. Она основана на хэш-таблице.

#### Особенности

- **Производительность**: Быстрое добавление, удаление и поиск элементов (в среднем O(1)).
- **Порядок**: Не гарантирует порядок элементов.
- **Память**: Эффективное использование памяти, но в худшем случае (много коллизий) производительность может ухудшиться до O(n).

#### Методы

`HashMap` не добавляет новых методов к интерфейсу `Map`, но предоставляет эффективную реализацию всех стандартных методов.

#### Применение

- Подходит для случаев, когда требуется быстрая производительность и нет необходимости в упорядоченности элементов.
- Идеален для хранения уникальных ключей с быстрым доступом к значениям.

### 2. `LinkedHashMap`

#### Описание

`LinkedHashMap` расширяет `HashMap` и использует двусвязный список для поддержания порядка вставки элементов.

#### Особенности

- **Производительность**: Быстрое добавление, удаление и поиск элементов (в среднем O(1)), немного медленнее, чем `HashMap`, из-за поддержания порядка вставки.
- **Порядок**: Гарантирует сохранение порядка вставки элементов или порядка доступа (если включен режим доступа).
- **Память**: Использует больше памяти на элемент по сравнению с `HashMap` из-за хранения ссылок.

#### Методы

- **`LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)`**: Конструктор позволяет задать начальную емкость, коэффициент загрузки и порядок (по вставке или по доступу).

#### Применение

- Подходит для случаев, когда требуется сохранение порядка вставки элементов.
- Идеален для приложений, где важен порядок элементов наряду с уникальностью.

### 3. `TreeMap`

#### Описание

`TreeMap` реализует интерфейс `NavigableMap` и основан на красно-черном дереве.

#### Особенности

- **Производительность**: Добавление, удаление и поиск элементов имеют логарифмическое время выполнения (O(log n)).
- **Порядок**: Гарантирует упорядоченность элементов по их естественному порядку или по предоставленному компаратору.
- **Память**: Использует больше памяти на элемент по сравнению с `HashMap` из-за хранения ссылок и дополнительных данных для поддержания структуры дерева.

#### Методы

- **Методы `NavigableMap`**: Добавляет методы для работы с подмножествами, такие как `subMap`, `headMap`, `tailMap`, а также методы для получения первого и последнего элементов.

#### Применение

- Подходит для случаев, когда требуется упорядоченность элементов и логарифмическое время выполнения операций.
- Идеален для задач, требующих диапазонных запросов и сортированных наборов данных.

### 4. `ConcurrentHashMap`

#### Описание

`ConcurrentHashMap` — это потокобезопасная реализация `Map`, основанная на сегментации.

#### Особенности

- **Производительность**: Высокая производительность в многопоточных средах благодаря сегментации, которая позволяет нескольким потокам одновременно модифицировать разные сегменты карты.
- **Порядок**: Не гарантирует порядок элементов.
- **Память**: Использует больше памяти на элемент по сравнению с `HashMap` из-за хранения сегментов.

#### Методы

- **Методы `ConcurrentMap`**: Добавляет методы для безопасного многопоточного доступа, такие как `putIfAbsent`, `remove` и `replace`.

#### Применение

- Подходит для многопоточных приложений, где требуется высокопроизводительный доступ к карте.
- Идеален для задач, требующих потокобезопасного доступа к данным.

## Optional

`Optional` в Java — это контейнер, который может содержать значение или быть пустым. Этот класс был введен в Java 8 как часть пакета java.util и предназначен для решения проблемы, связанной с использованием null, что часто приводит к ошибкам типа NullPointerException.

`Optional` позволяет разработчикам явно указывать, что значение может быть отсутствующим, что делает код более читаемым и безопасным. Вместо того чтобы проверять на null, мы используем методы Optional, которые делают работу с потенциально отсутствующими значениями более понятной и безопасной

### Основные методы Optional
```java
    import java.util.Optional;

    // Создание
    Optional<String> emptyOptional = Optional.empty(); // Пустой Optional
    Optional<String> optional = Optional.of("Hello"); // Optional с ненулевым значением
    Optional<String> optional = Optional.ofNullable(maybeNullValue); // Optional с потенциально нулевым значением

    // Методы
    boolean isPresent(); // Проверяет, содержит ли Optional значение
    void ifPresent(Consumer<? super T> action); // Выполняет действие, если значение присутствует
    T get(); // Возвращает значение, если оно присутствует. Бросает NoSuchElementException, если значение отсутствует
    T orElse(T other); // Возвращает значение, если оно присутствует, иначе возвращает указанное значение по умолчанию
    T orElseGet(Supplier<? extends T> other); // Возвращает значение, если оно присутствует, иначе вызывает и возвращает значение из переданного Supplier
    String value = optional.orElseGet(() -> "Default Value from Supplier");
    T orElseThrow(Supplier<? extends X> exceptionSupplier); // Возвращает значение, если оно присутствует, иначе бросает исключение, создаваемое переданным Supplier
    String value = optional.orElseThrow(() -> new RuntimeException("Value not present"));
    Optional<U> map(Function<? super T, ? extends U> mapper); // Применяет функцию к содержимому Optional, если значение присутствует, и возвращает Optional с результатом
    Optional<Integer> length = optional.map(String::length);
    Optional<U> flatMap(Function<? super T, Optional<U>> mapper); // Применяет функцию, которая возвращает Optional, и "разворачивает" его, если значение присутствует
    Optional<Integer> length = optional.flatMap(s -> Optional.of(s.length()));
    Optional<T> ilter(Predicate<? super T> predicate); // Возвращает Optional с содержимым, если оно удовлетворяет условию, иначе возвращает пустой Optional
    Optional<String> filtered = optional.filter(s -> s.length() > 3);
    Optional<T> or(Optional<? extends T> other); // Возвращает этот Optional, если значение присутствует, иначе возвращает указанный Optional
    Optional<String> result = optional.or(Optional.of("Default Value"));
    Stream<T> stream(); // Возвращает поток, состоящий из единственного значения, если оно присутствует, иначе возвращает пустой поток
```

## Stream API
```java
    Stream - последовательность элементов, потенциально бесконечная, с возможностью применять к ней многоэтапные преобразования

    java.until.stream; - пакет, в котором хранится весь Stream API

    IntStream stream = IntStream.iterate([startValue], [lambdaFunction]);
    * startValue - начальное значение, с которого начинается последовательность
    * lambdaFunction -  функция, которая определяет как меняется следующий элемент последовательности в сравнении с предыдущим:
    n -> n+1 - следующий элемент будет на 1 больше предыдущего

    * Структура кода Stream состоит из 3-х частей:
    1. Объявление самой последовательности (IntStream stream = IntStream.iterate([startValue], [lambdaFunction]))
    2. Выполнение какого то количества преобразований последовательности (filter, limit, map)
    3. Терминальная операция, которая позволяет получить полезный результат от стрима (sum)

    Способы получения Stream-а:

    1. Можно получить из любой #Коллекции# с использовованием команды stream:
    Set<Type> set = ...;
    Stream<Type> stream = set.stream;
    2. Можно получить из потока символов (необходимо закрывать stream.close()):
    BufferedReader reader = ...;
    Stream<String> stream = reader.lines();
    3. Можно получить последовательность из директорий на диске (необходимо закрывать stream.close()):
    Path path = ...;
    Stream<Path> stream = Files.list(path); - возвращает содержимое директорий на один уровень
    Stream<Path> stream = Files.walk(path); - рекурсивно обойдет и поддиректории тоже
    4. Можно получить из строки:
    IntStream chars = "[String]".chars();
    5. Можно генерировать при помощи какой то функции:
    DoubleStream randomNumbers = DoubleStream.generate(Math::random);
    * В метод DoubleStream.generate([Supplier]) - передается метод, который реализует интерфейс Supplier, т.е. ничего не получает, но что то отдает
    6. Можно получить итерированием какой то функции:
    IntStream stream = IntStream.iterate(0, n -> ++n);
    7. Можно получить из последовательности чисел:
    IntStream stream = IntStream.range(0, 100); - получение чисел от 0 до 99
    IntStream stream = IntStream.rangeClosed(0, 100); - получение чисел от 0 до 100
    8. Можно получить из конкатинации 2-х других стримов:
    IntStream newStream = IntStream.concat(stream1, stream2);
    9. Можно получить пустой стрим:
    IntStream newStream = IntStream.empty();
    10. Можно получить стрим из массива:
    double[] array = ...;
    DoubleStream stream = Arrays.stream(array);
    11. Можно явно перечислить все элементы стрима:
    IntStream newStream = IntStream.of(2,4,5,6,7,8,9,10);

    Преобразование последовательностей:

    stream.filter(n -> {condition}); - использование фильтрации последовательности (к каждому элементу последовательности применяется данная функция и проверяет, выполняется ли условие)
    * n -> n % 5 == 0 - пример написания условия фильтрации
    stream.skip([count]); - позволяет пропустить count значений
    stream.limit([count]); - оставляет первые count элементов последовательности
    stream.map(n -> n*n); - применяет какую то функцию к каждому элементу последовательности
    stream.mapToObj(Integer::toString); - преобразует все элементы последовательности к другому типу
    stream.flatMapToInt(s -> [return Stream]);- похожа на map, только принимает функцию, возвращающую Stream, после превращения всех элементов в набор Stream-ов конкатинирует их и получается один Stream
    stream.distinct(); - убирает дубликаты элементов
    stream.sorted(); - сортирует последовательность по возрастанию
    * Если последовательность состоит из объектов, то можно передать в данную функцию компаратор

    stream.peek(System.out::println); - позволяет посмотреть какие значения сейчас в последовательсности
    * Принимает интерфейс Consumer

    Терминальные операции: - которые запускают выполенние стрима
    * После искользоваться терминальной операции стрим перестает быть действительным и не может использоваться дальше

    stream.forEach(System.out::println); - приминяет функцию к каждому элементу последовательности
    * Принимает интерфейс Consumer
    OptionalInt result = stream.findFirst(); - возвращает первый элемент последовательности, который может быть null, поэтому тип возвращаемого значения OptionalInt
    Int result = stream.findAny(); - возвращает первый элемент последовательности кроме null
    boolean bool = stream.allMatch(s -> [condition]); - проверяет удволетворяют ли все элементы последовательности данному условию
    boolean bool = stream.anyMatch(s -> [condition]); - проверяет удволетворяет ли хотя бы один элемент последовательности данному условию
    boolean bool = stream.noneMatch(s -> [condition]); - проверяет НЕ удволетворяют ли все элементы последовательности данному условию

    stream.min() | stream.max();; - возвращает минимальный или максимальный элемент последовательности
    * Если последовательность не числовая, то принимает Comparator.comparing(...);
    stream.sum(); - возвращает сумму элементов последовательности
    stream.count(); - возвращает количетсво элементов последовательности

    stream.collect(Сollectors.to[List | Set | ...]); - преобразует последовательность в какой то тип
    * преобразует не только в коллекции, все стандартные варианты хранятся в Сollectors
    stream.reduce([defaultValue], [BinaryOperator<T>]); - производит свертку всех элементов (последовательно применяет ко всем парам элементов какую то функцию, пока не останится один элемент)


    stream.close(); - закрытие стрима, обязательная команда, если стрим работает с какими то системными ресурсами, например, с файлами
```

## Модификаторы доступа
```java
    public - разрешен доступ отовсюду без ограничений
    * В одном файле .java может быть только один класс с модификатором public и его имя должно совпадать с именем файла (причем очень важен регистр символов)
    protected - доступ разрешен только для классов наследников и классов текущего пакета
    [пустота] - если модификатор отсутсвует, это означает, что доступ только в пределах пакета
    private - доступ только в пределах класса (сам класс не может иметь модификатор private)
    * protected и private нельзя прменять к классам верхнего уровня, их можно применять только к вложеным классам
    * Если попытаться унаследоваться от класса, находящегося в другом пакете, то получившийся класс, получит доступ только к методам и полям с ключевыми словами public и protected
```
## Ключевые слова классов
```java
    final - означает, что от данного класса нельзя наследоваться
    abstract - означает, что данный класс обстрактный, т.е. является основой для других классов (нельзя создавать его экземпляры)
    * Пример: класс "фигура", который является абстрактным и сам по себе не имеет смысла, является скилетом для других фигур
```
## Ключевые слова переменных
```java
    volatile - используется для указания компилятору и виртуальной машине Java (JVM), что значение переменной может изменяться различными потоками. 
    final - означает, что значение переменной можно задать только 1 раз и потом изменить его нельзя
    * Переменная объявленная как final считается константой и записывается: КОНСТАНТА_1
    * К переменную константе не обязательно сразу присваивать значение, его можно присвоить при инициализации класса
    * Если данная переменная является ссылкой, то нельзя менять только значение ссылки, а объект по ссылке менять можно
```
## Ключевые слова методов
```java
    final - означает, что функцию нельзя переопределить в классах-наследниках
    * Если написать final к переменой метода, то нельзя будет имзенить значение данной переменной внутри метода. Если данная переменная является ссылкой, то нельзя менять только значение ссылки, а объект по ссылке менять можно
    * Любой private метод автоматически становится и final
    abstract - означает, что данный метод обязательно должен переопределить класс-наследник (можно писать только в абстрактных классах)
    * Данные методы пишутся без тела, т.е. только объявление метода с ключевым словом abstract
    synchronized - указывает на то, что данный метод может выполняться только одним потоком (нужен в многопоточности).
```
## Модификаторы:
```java
    static - данный модификатор указывает на  привязку субъекта  к текущему классу.
    ДОКУМЕНТАЦИЯ: https://javarush.com/groups/posts/modifikator-static-java
    * Статические методы исполняются в контексте класса, а не экземпляра, поэтому this недоступен, как и не static объекты класса
    * Если переменная не статическая, то у каждого нового объекта данного класса будет своё значение этой переменной, меняя которое мы меняем его исключительно в одном объекте
    * К статическим переменным, как правило обращаются не по ссылке на объект, а по имени класса
    ** Особенности:
    1. Вы НЕ можете получить доступ к НЕ статическим членам класса, внутри статического контекста
    2. Статические поля и методы НЕ потокобезопасны
    3. Статические методы имеют преимущество в применении, т.к. отсутствует необходимость каждый раз создавать новый объект для доступа к таким методам
    4. Вы НЕ можете переопределять статические методы
    5. Модификатор также может быть объявлен в статичном блоке
    6. Статические методы связываются во время компиляции, в отличие от связывания виртуальных или не статических методов, которые связываются во время исполнения на реальном объекте
    7. Статические поля или переменные инициализируются после загрузки класса в память
```
## Типы возвращаемых данных
```java
    void - означает, что функция ничего не возвращает
    Также возможные возвращаемые типы перечислены в #Типы данных#
```
## Специальные символы
```java
    \n - перевод курсора на новую строку
    \t - TAB (4 пробела)
    \" - перевод символа \" к строковому формату
    \\ - вывод обычного \
```