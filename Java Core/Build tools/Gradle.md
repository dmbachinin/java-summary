# Gradle

```plantext
    Gradle — это современная, гибкая и мощная система сборки, которая широко используется для автоматизации процесса сборки, тестирования и развертывания программного обеспечения. Она была разработана как альтернатива существующим инструментам, таким как Apache Ant и Apache Maven, предлагая более декларативный и удобный подход.
```

- [Gradle](#gradle)
  - [Разница между build.gradle и build.gradle.kts](#разница-между-buildgradle-и-buildgradlekts)
  - [Основная структура build.gradle.kts](#основная-структура-buildgradlekts)
    - [Плагины (Plugins)](#плагины-plugins)
    - [### Плагин Java в Gradle: подробный разбор](#-плагин-java-в-gradle-подробный-разбор)
    - [Основные возможности плагина `java`](#основные-возможности-плагина-java)
    - [Какие этапы добавляет плагин `java`?](#какие-этапы-добавляет-плагин-java)
    - [Откуда берутся зависимости?](#откуда-берутся-зависимости)
      - [Основные типы репозиториев](#основные-типы-репозиториев)
      - [Пример указания репозиториев](#пример-указания-репозиториев)
    - [Как указываются зависимости?](#как-указываются-зависимости)
    - [Как Gradle скачивает зависимости?](#как-gradle-скачивает-зависимости)
    - [Пример полного конфигурационного файла для Java-проекта](#пример-полного-конфигурационного-файла-для-java-проекта)
    - [Вывод](#вывод)

## Разница между build.gradle и build.gradle.kts

Сравнительная таблица между **`build.gradle`** (Groovy DSL) и **`build.gradle.kts`** (Kotlin DSL):

| **Характеристика**         | **`build.gradle` (Groovy DSL)**                          | **`build.gradle.kts` (Kotlin DSL)**                     |
|----------------------------|--------------------------------------------------------|-------------------------------------------------------|
| **Язык**                   | Groovy (динамический язык)                             | Kotlin (статически типизированный язык)              |
| **Синтаксис**              | Менее строгий, допускает опускание скобок             | Строгий, требует явного соблюдения синтаксиса        |
| **Автодополнение в IDE**   | Ограниченное, сложнее для рефакторинга                | Отличное, с проверкой типов и подсказками           |
| **Поддержка документации** | Большинство примеров и официальной документации       | Более ограниченная документация и примеры           |
| **Гибкость**               | Высокая за счёт динамической природы языка            | Меньшая гибкость, но большая предсказуемость        |
| **Совместимость**          | Полностью совместим с любыми версиями Gradle          | Поддерживается начиная с Gradle 5.0                 |
| **Производительность IDE** | Немного медленнее, так как Groovy — динамический язык | Быстрее благодаря статической типизации             |
| **Кривая обучения**        | Проще для начинающих, если не требуется строгий синтаксис | Требует знаний Kotlin, но более дружелюбен для опытных разработчиков |
| **Популярность**           | Используется чаще, особенно в устаревших проектах     | Набирает популярность для новых проектов            |
| **Совместимость плагинов** | Поддерживает все плагины                              | Не все плагины поддерживают Kotlin DSL              |
| **Когда использовать**     | Для работы с существующими проектами или плагинами, где Groovy необходим | Для новых проектов или если используется Kotlin в разработке |

## Основная структура build.gradle.kts

### Плагины (Plugins)

`Плагины в Gradle` — это модули, которые расширяют функциональность проекта, добавляя предопределенные задачи, конфигурации и зависимости. Они позволяют автоматизировать типовые задачи, такие как компиляция кода, тестирование, сборка артефактов, интеграция с другими инструментами, разработка Android-приложений и многое другое.

**Зачем нужны плагины?**

1. **Автоматизация задач**: Плагины добавляют заранее определенные задачи, например, компиляцию, создание JAR-файлов или тестирование.
2. **Повышение производительности**: Снижают количество ручной работы, предоставляя готовые решения.
3. **Стандартизация**: Помогают использовать общепринятые стандарты и практики в разработке.
4. **Удобство**: Устраняют необходимость писать пользовательские задачи для типичных действий.
Поддержка различных языков и платформ: Например, плагины для Kotlin, Java, Android, Scala и других технологий.

**Пример подключения плагинов:**

```kotlin
    plugins {
        java // Позволяет собирать Java-проекты
        application // Добавляет задачи для создания исполняемых приложений
        base // Основной плагин, который предоставляет базовые задачи (например, clean)
    }
```

### ### Плагин Java в Gradle: подробный разбор

Плагин **`java`** является одним из основных плагинов Gradle, предоставляющим инструменты для сборки, тестирования и упаковки Java-приложений. Он упрощает работу с проектами на Java, автоматизируя стандартные этапы разработки.

---

### Основные возможности плагина `java`

1. Добавляет стандартные задачи для работы с Java-проектами (компиляция, тестирование, упаковка).
2. Управляет зависимостями и их версиями.
3. Организует файловую структуру проекта (по соглашению).
4. Поддерживает работу с артефактами (JAR-файлы, тестовые отчеты и др.).

---

### Какие этапы добавляет плагин `java`?

При подключении плагина `java`, Gradle автоматически добавляет следующие **этапы сборки**:

| **Этап/Задача**      | **Описание**                                                                 |
|----------------------|-----------------------------------------------------------------------------|
| `clean`              | Удаляет все сгенерированные файлы (каталог `build/`).                       |
| `compileJava`        | Компилирует исходный код из папки `src/main/java` в байт-код.               |
| `compileTestJava`    | Компилирует тестовый код из папки `src/test/java`.                          |
| `processResources`   | Копирует файлы из `src/main/resources` в `build/resources/main`.            |
| `processTestResources`| Копирует файлы из `src/test/resources` в `build/resources/test`.           |
| `test`               | Выполняет тесты, используя JUnit или другой тестовый фреймворк.             |
| `jar`                | Создает JAR-файл из скомпилированных классов и ресурсов.                   |
| `assemble`           | Выполняет задачи `compileJava`, `processResources` и `jar`.                |
| `build`              | Выполняет полный цикл сборки (включая `test` и `assemble`).                |

---

### Откуда берутся зависимости?

Зависимости в Gradle хранятся в **репозиториях** — это централизованные хранилища артефактов, таких как библиотеки, плагины и другие модули. При использовании плагина `java`, вы указываете репозитории, а Gradle автоматически скачивает зависимости в локальный кэш.

#### Основные типы репозиториев

1. **Maven Central**:
   - Самый популярный репозиторий для Java-зависимостей.
   - Указывается через `mavenCentral()`.

2. **JCenter** (устарел):
   - Ранее использовался как альтернатива Maven Central.

3. **Локальный репозиторий**:
   - Артефакты могут быть сохранены локально, например, в `.m2` (Maven) или собственном каталоге.

4. **Google**:
   - Используется для Android-проектов.

#### Пример указания репозиториев

```kotlin
repositories {
    mavenCentral()
    google()
}
```

---

### Как указываются зависимости?

1. **Указание версии Java:**
   Плагин `java` добавляет поддержку для установки версии Java через опцию `JavaToolchain`.

   ```kotlin
   java {
       toolchain {
           languageVersion.set(JavaLanguageVersion.of(17)) // Использование Java 17
       }
   }
   ```

2. **Добавление зависимостей:**
   Зависимости указываются в секции `dependencies`. Вы можете добавить зависимости с разными конфигурациями:

   | **Конфигурация**      | **Описание**                                                                                   |
   |-----------------------|-----------------------------------------------------------------------------------------------|
   | `implementation`      | Основные зависимости, используемые только внутри проекта.                                      |
   | `api`                 | Зависимости, доступные для всех модулей, которые зависят от текущего.                         |
   | `testImplementation`  | Зависимости, используемые только в тестах.                                                    |
   | `runtimeOnly`         | Зависимости, требуемые только во время выполнения (не включаются в компиляцию).                |

   Пример:

   ```kotlin
   dependencies {
       implementation("org.apache.commons:commons-lang3:3.12.0") // Зависимость из Maven Central
       testImplementation("junit:junit:4.13.2")                  // Зависимость для тестов
   }
   ```

---

### Как Gradle скачивает зависимости?

1. **Скачивание из репозитория:**
   Когда вы добавляете зависимость в проект, Gradle ищет её в указанных репозиториях.
   - Например, `implementation("org.apache.commons:commons-lang3:3.12.0")` заставляет Gradle искать библиотеку в `mavenCentral()`.

2. **Локальный кэш:**
   Зависимости загружаются в локальный кэш (`~/.gradle/caches`) и используются повторно при следующей сборке, что экономит время.

3. **Контроль версий:**
   Вы указываете конкретную версию зависимости (например, `3.12.0`), и Gradle гарантирует её загрузку.

4. **Транзитивные зависимости:**
   Gradle автоматически загружает зависимости, которые нужны для работы подключенной библиотеки. Например, если библиотека `A` зависит от `B`, Gradle скачает обе.

---

### Пример полного конфигурационного файла для Java-проекта

```kotlin
plugins {
    java
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation("org.apache.commons:commons-lang3:3.12.0") // Основная библиотека
    testImplementation("junit:junit:4.13.2")                 // Библиотека для тестов
}

tasks.test {
    useJUnit() // Указывает использовать JUnit для тестирования
}
```

---

### Вывод

Плагин `java` автоматизирует ключевые этапы разработки, такие как компиляция, тестирование и создание артефактов. Все зависимости загружаются из репозиториев (например, Maven Central) и сохраняются в локальный кэш. Это делает процесс управления библиотеками быстрым, стабильным и предсказуемым.
