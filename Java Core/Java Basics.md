# Основы Java

- [Основы Java](#основы-java)
  - [Основы java](#основы-java-1)
  - [Полезные заметки](#полезные-заметки)
  - [Компиляция java кода](#компиляция-java-кода)
  - [Формирование JAR](#формирование-jar)
    - [Компиляция JAR-файла](#компиляция-jar-файла)
    - [Основные флаги для создания JAR-файла](#основные-флаги-для-создания-jar-файла)
    - [Манифест файл MANIFEST.MF](#манифест-файл-manifestmf)
    - [Запуск JAR-файлов](#запуск-jar-файлов)
    - [Подключение JAR-файлов](#подключение-jar-файлов)
  - [javadoc](#javadoc)
  - [Команды](#команды)
    - [Вывод информации](#вывод-информации)
    - [Вввод информации](#вввод-информации)
    - [Математика](#математика)
    - [Случайные числа](#случайные-числа)
    - [Логические операции](#логические-операции)
    - [Арифметические операции](#арифметические-операции)
    - [Побитовые операции](#побитовые-операции)
    - [Циклы](#циклы)
  - [Функции](#функции)
    - [Синтаксис функций](#синтаксис-функций)
    - [lambda Функция](#lambda-функция)
  - [Обработка ошибок](#обработка-ошибок)

## Основы java

`Java` - компилируемый, строго типизированный объектно-ориентированный язык программирования общего назначения

- В Java исопльзуется кодировка Unicode-16

Терминология:

- `JDK(Java Development Kit)` - комплект разработчика, включающий в себя компилятор
- `JAR(Java ARchive)` - это Java-архивы, в которых содержатся компоненты программы (без зависимых библиотек)
- `UBER JAR(Uber Java ARchive)` - это Java-архивы, в которых помещены все зависымые библиотеки
- `JVM(Java Virtual Machine)` - виртульная машина Java, благодаря ей можно запускать скомпилированный - Java-код
- `JRE(Java Runtime Environment)` - виртуальная машина, для запуска Java-приложений (состоит из JVM и - библиотека Java-классов)
- `JIT(Just-in-time compilation)` - компилятор, который переводит код в байт-код, который выполняет компьютер

## Полезные заметки

**Изменить версию java** по умолчанию в системе Mac (JDK нужной версии должен быть установлен)

```shell
    export JAVA_HOME=$(/usr/libexec/java_home -v VERSION)
    export PATH=$JAVA_HOME/bin:$PATH
```

## Компиляция java кода

```shell
  javac [Main.java] # Команда для компиляции файлов (будет создан файл Main.class)
  java Main # Запустить скомпилированный файл (.class указывать не нужно)
  javac -d bin ./src/*.java  # Скомпилировать все файлы из папки и записать результат в bin
  javac -cp lib1.jar:lib2.jar -d bin ./src/*.java # Скомпилировать проект с использованием сторонних библиотек
  java -classpath ./bin Main # Запуск проекта из папки bin
  #    * -classpath можно задать -cp
  java -classpath ./bin:MyJar1.jar:MyJar2.jar Main # Запуск проекта из папки bin с подключением jar файлов

  # Если класс принадлежит пакету, то компиляция выглядит следующим образом
  javac package/Main.java
  java package.Main
```

## Формирование JAR

### Компиляция JAR-файла

Создание JAR-файла осуществляется с использованием инструмента `jar`, который входит в состав JDK. Инструмент `jar` предоставляет различные флаги для управления процессом создания JAR-файлов.

Опция `-C` в команде `jar` используется для указания каталога, в котором находятся файлы для включения в архив JAR. В вашем примере `-C classes/` означает, что содержимое каталога `classes/` будет включено в JAR-файл.

Например, если у вас есть структура каталогов следующего вида:

```plantext
classes/
    com/
        example/
            MyClass.class
            AnotherClass.class
```

Использование `-C classes/` гарантирует, что содержимое каталога `classes/` будет включено в JAR-файл, а не просто сам каталог.

### Основные флаги для создания JAR-файла

```shell
    jar cf myfile.jar -C classes/ . # `c` Создать новый JAR-файл
    jar cf myfile.jar -C classes/ . # `f` Указать имя выходного файла JAR.
    jar cfm myfile.jar MANIFEST.MF -C classes/ . # `m` Включить манифест-файл
    jar tf myfile.jar # `t` Показать содержимое JAR-файла
    jar xf myfile.jar # `x` Извлечь содержимое из JAR-файла
    jar jar uf myfile.jar -C new_classes/ . # `u` Обновить существующий JAR-файл
    jar cvf myfile.jar -C classes/ . # `v` Включить подробный вывод
    jar cf0 myfile.jar -C classes/ . # `0` Создать JAR-файл без сжатия.
```

### Манифест файл MANIFEST.MF

Манифест-файл указывает метаданные о содержимом JAR-файла, включая точку входа для исполняемых JAR-файлов. Создайте файл `MANIFEST.MF` со следующим содержимым:

```makefile
    Manifest-Version: 1.0
    Main-Class: MyClass
```

Манифест указывает, что `MyClass` содержит метод `main` и является точкой входа для JAR-файла.

Файл `MANIFEST.MF` в JAR-файле может содержать следующую информацию:

```makefile
    Manifest-Version: 1.0 # Версия спецификации манифеста. Обычно это "1.0"
    Main-Class: com.example.Main # Имя класса с методом `main`, который будет точкой входа при запуске JAR-файла
    Class-Path: lib/library1.jar lib/library2.jar # Путь к зависимым JAR-файлам. Разделяется пробелами
    Implementation-Title: MyApp # Название программы
    Implementation-Version: 1.0 # Версия программы
    Implementation-Vendor: MyCompany # Поставщик программы
    Specification-Title: MyApp Specification # Название спецификации, которую реализует программа
    Specification-Version: 1.0 # Версия спецификации
    Specification-Vendor: MyCompany # Поставщик спецификации
    Sealed: true # Указывает, что пакет в JAR-файле должен быть запечатан. Если указано "true", все классы в этом пакете должны быть из одного JAR-файла
    Built-By: DeveloperName # Информация о сборщике (например, имя разработчика)
    Created-By: 1.8.0_201 (Oracle Corporation) # Инструмент, использованный для создания JAR-файла
    Signature-Version: 1.0 # Версия подписи JAR-файла
```

### Запуск JAR-файлов

```shell
    java -jar MyApp.jar # Запуск исполняемого JAR-файла, содержащего точку входа, указанную в манифесте
```

### Подключение JAR-файлов

Для использования JAR-файлов в вашем проекте (например, в качестве библиотек), нужно указать их в класспасе (`classpath`). Есть несколько способов это сделать.

```shell
    java -cp MyLibrary.jar com.example.Main # Указание в командной строке
    java -cp lib1.jar:lib2.jar com.example.Main # Указание нескольких JAR-файлов
    #   * На Windows используйте точку с запятой (`;`) вместо двоеточия (`:`)
    java -cp "lib/*" com.example.Main # Использование wildcard для указания всех JAR-файлов в директории
```

## javadoc

`javadoc` позволяет писать документацию к классам и методам проекта.
Не пишет документацию для private и доступа в пределах пакета

```java
    /**
    Комментарий для документации (javadoc)
    В данном блоке можно использовать HTML заметку

    @see Ссылка_на_другие_классы - указывает ссылку на другой класс в тексте отмечается, как смотри также, например, @see полное-имя-класса#имя-метода
    @author: Dmitriy Bachinin
    @version: 1.5
    {@link пакет.класс#член_класса метка} - ссылка на другой класс, может иметь любой текст (в отличии от @see)
    {@docRoot} - получение относительного пути к корневой папке, в которой находится документация
    {@inheritDoc} - наследование документации базового класса, ближайшего к документируемому
    @since 1.3 - позволяет задать версию кода, с которой началось использование некоторой функции
    @param имя-параметра описание - полезен для документации методов, где имя-параметра - это индентификатор параметров в списке параметров метода
    @return описанание - объяснение того, что именно возвращает метод
    @throws полное_имя_класса_ошибки описание - указывает какие исключения способен вызвать данный метод при своем вызове
    */
```

## Команды

### Вывод информации

```java
System.out.print("[Инф]"); // Команда для вывода информации
// * Несколько подряд идущих команд принт будут сливаться в одну строку без переносов и пробелов.
System.out.println("[Инф]") // В конце каждой строчки ставит \n
System.out.printf("[Инф] %[params]",params); // Команда для вывода информации с форматированием строки
```

### Вввод информации

```java
import java.util.Scanner; // Подключение класса для работы с вводом
Scanner in = new Scanner(System.in); // Насройка сканера на ввод из консоли
String str = in.nextLine(); // Получение строки из источника ввода
int num = in.nextInt(); // Получение целого числа из источника ввода
```

### Математика

Класс Math:
ДОКУМЕНТАЦИЯ: <https://javarush.com/groups/posts/2762-klass-java-math-i-ego-metodih>

Класс Math располагается в пакете java.lang

```java
    Math.abs([Number]); // возращает модуль данного числа
    Math.toDegrees(double [angrad]) // переводит угол angrad, измеряемый в радианах, в градусы
    Math.toRadians(double [angdeg]) // переводит угол angdeg, измеряемый в градусах, в радианы
    Math.sin(Math.toRadians([angdeg])) // вычисление синуса от радиан
    Math.cos(Math.toRadians([angdeg])) // вычисление косинуса от радиан
    Math.pow(double [A], double [B]) // возведение числа A в степень B
    Math.sqrt(double [A]) // корень из числа
    Math.cbrt(double [A]) // кубический корень из числа
    Math.random() // возвращает случайное число от 0.0 до 1.0
    Math.round(double [A]) // округление числа до целого значения по правилам математики
    Math.floor(double [A]) // округление числа в меньшую сторону до целого
    Math.ceil(double [A]) // округление числа в большую сторону до целого
    Math.PI // возвращает число Пи
    Math.E // возвращает число Е
    Math.max([A], [B]) // возвращает наибольшее число из двух
    Math.min([A], [B]) // возвращает минимальное число из двух

    BigInteger // целые числа, которые могут быть очень большими
    BigDecimal // вещественные числа, которые могут быть очень большими
    * данные классы необходимо имортировать import java.math *;
    ДОКУМЕНТАЦИЯ: https://metanit.com/java/tutorial/12.2.php
```

### Случайные числа

ДОКУМЕНТАЦИЯ: <https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Random.html>

```java
Random rand = new Random({seed}); // Cоздает новый тип генератора случайных чисел
// * если в seed вписать число самостоятельно, то рандом перестанет быть случайным и будет повторяться каждый раз
// * если ничего не указывать в параметрах метода, тогда значения будут случайными при каждом запуске программы
```

### Логические операции

Операции сравнения: `>,<,>=,<=, ==, !=`

Операции над логическими типами:

- `&&` - логическое "И" (по сокращенной схеме, т.е если A = 0, то B не вычисляется).
- `&` - логическое "И" (по полной схеме, т.е вычисляются А и В)
- `||` - логическое "ИЛИ" (по сокращенной схеме, т.е если A = 1, то B не вычисляется)
- `|` - логическое "ИЛИ" (по полной схеме, т.е вычисляются А и В)
- `!` - логическое "НЕ"
- `^` - логическое "исключающее ИЛИ" (возвращает true, если A != B, формула А*!В + !А*В)

```java

    value &= exp; // краткая записи выражения value = value & exp;

    // Оператор if

    if (condition){ ... }
    else if (condition) { ... }
    else { ... }

    // Если под оператором исопльзуется только одно дейтсвие то {} можно не ставить:
    if (condition)
        // ...
    else
        // ...

    (anObject instanceof [ClassName]) // проверяет, является ли данный объект экземпляром заданного класса

    // Тернарный условный оператор:
    (condition) ? [valIsTrue] : [valIsFalse] // запись условия в одну строчку

    // Оператор switch

    switch ([param]){
        case [val1]: - попадает сюда, если param == val1
            [move1];
            break; - если не писать "break", то выполнение перейдет на следующий case без проверки его условия
        case [val2]:
            [move2];
            break;
        default: - попадает сюда, если не нашлось совпадения со значением param
            [default move];
    }
    // * Ветвления доступны по типам: int, String, char
```

### Арифметические операции

```java
    int sum = a + b; // сложение двух чисел, краткая запись (a += b)
    int diff = a - b; // разность двух чисел, краткая запись (a -= b)
    int div = a / b; // целочисленные деление двух целых чисел, краткая запись (a /= b)
    int rem = a % b; // остаток от деления двух чисел, краткая запись (a %= b)
    int mult = a * b; // умножение двух чисел, краткая запись (a *= b)
    // a = a + 1 => a++, возращает значение a, если ++a, то вернется значение a+1
    // a = a - 1 => a--, возращает значение a, если --a, то вернется значение a-1
```

### Побитовые операции

ДОКУМЕНТАЦИЯ: <https://javarush.com/groups/posts/1925-pobitovihe-operacii>

```java
    int neg = ~a; // применение отрицания к каждому биту числа
    int and = a & b; // попарное применение & между битами 2-х чисел
    int or = a | b; // попарное применение | между битами 2-х чисел
    int xor = a ^ b; // попарное применение ^ между битами 2-х чисел
    Пример:
    a = 0001
    b = 0101
    and = 0001 // a & b
    or = 0101 // a | b
    xor = 0100 // a ^ b
    int arithmeticShiftRight = a >> [int count]; // сдвиг битов числа на count позиций вправо (деление на 2)
    * Если входное число отрицательное, где крайний левый бит равен 1, то пустые места будут заполнены 1
    * Если входное число положительное, где крайний левый бит равен 0, то пустые места будут заполнены 0
    int arithmeticShiftRight = a >>> [int count]; // сдвиг битов числа на count позиций вправо (деление на 2)
    * При таком сдвиге слева всегда дописываестся 0 (Результатом всегда будет положительное целое число)
    int shiftLeft = a << [int count]; // сдвиг битов числа на count позиций влево (умножение на 2)
    * При нем теряются старшие биты а младшие заполняются нулями
```

### Циклы

```java
    [tagName]:
    while(condition){ ... } // пока условие выполняется цикл будет продолжать выполнение
    * [tagName]: // позволяет задать имя для цикла, что позволит указать конкретный цикл в операторах break tagName; и continue tagName; в коде, чтобы завершить конкретный цикл по его имени

    do{ ... }while(condition); // цикл с постусловием, в нем первая операция выполняется всегда

    [tagName]: // присвоение названия функции для возможности использовать break; или continue; на определенный цикл
    for ([инициализация переменной счетчика]; [условие прекращения итераций]; [дейтсвие, которое выполяется после каждой итерации]){ ... } // шаблон для создания цикла for
    for (int i=0; i<[maxVal]; i++){ ... } // цикл со счетчиком (стандарная запись)
    for ([type] arg : args){ ... } // перебор всех элементов массива

    * break tagName; // досрочно завершает цикл
    * continue tagName; // переход к следующей итерации цикла
```

## Функции

### Синтаксис функций

```java
    [#Модификаторы доступа#] [#Модификаторы#] [#Ключевые слова методов#] [#Типы возвращаемых данных#] [Имя]([тип параметра] [имя параметра]) {body} - шаблон для создания функции
    * Если в данном методе может вызываться ошибка с типом #Проверяемые#, то при создании функции после параметров ставится throws -> ... [Имя]([тип параметра] [имя параметра]) throws [Exception1], [Exception2]

    public static void main(String[] args){body} - написание функции main, которая выполняется при запуске программы
    * в переменную args записываются переменные из командной строки
    static int func(int... numbers){body} - конструкция с ... позволяет передать любое количество переменных, например, func(1,2,3,4) -> numbers = {1,2,3,4}
    * Можно передать массив, что будет обработанно корректно
    * Можно передать 0 аргументов
```

### lambda Функция

ДОКУМЕНТАЦИЯ: <https://javarush.com/groups/posts/lambda-vihrazhenija-v-java-chast-1>

```java
    (param1, param2) -> { - создание функции, ей можно заменить только функциональный интерфейс
    ...
    return ... ;
    }

    {FunctionalInterface} name = x -> {return ...} - пример созздания лямбда функции при помощи функционального интерфейса
    * Так как в функциональной мнтерфейсе всегда один метод, то программа знает какую функцию мы представляем в виде лямбда выражения (она знает типы и количество входных параметров, а также возвращаемое значение)

    name.functionName(x); - пример вызова функции для определенного функционального интерфейса
    * functionName(x) - это имя функции, которая была в функциональном интерфейсе
```

## Обработка ошибок

Классификация исключений:

1. `Исключения JVM` - возникают при компиляции программы
2. `Возникающие в пользовательском коде`:
   - `Проверяемые` - означает, что JVM следит в каком месте они вызываются и они не могут быть вызваны просто так (компилятор требует их декларировать и обрабатывать). Данные исключения принадлежат к классу Exception
   - `Непроверяемые` - ошибки такого типа могут вызываться везде. Данные иключения принадлежат к классу RuntimeException

```java
    throw new [класс исключения] ("Текст сообщения") // вызов определенной ошибки с текстом сообщения

    // Если мы хотим создать свое исключение, то необходимо создать класс, который наследуется от Exception или RuntimeException (в зависимости от того, какой тип сключения нам нужен)

    try { ... } // блок кода, где могут появляться ошибки
    catch (ExceptionСlass1 | ExceptionСlass2 e) {
    e.getMessage(); // показать только сообщение об ошибке
    e.printSrackTrace(); // вывести стек вызовов
    } // блок, обработки ошибки
    catch (ExceptionСlass3 ignore) {} // Возможность игнорировать ошибку
    finally {...} // блок, который всегда выполнится после try-catch; (Обычно данный блок используют для освобождения памяти)

    // try c ресурсами:

    try (Resource r1 = new Resource(); Resource r2 = new Resource();...){
        // ...
    }
    catch {...} // октрытие блока catch с ресурсами
    // * Особенностью данной контсрукции является то, что при завершении работы блоков будет автоматически вызвана команда r1.close(), r2.close() ...
    // ** Ресурсом является любой класс, который реализует интерфейс AutoCloseable, т.е. имеет команду close()
```
