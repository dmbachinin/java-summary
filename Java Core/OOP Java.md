# ООП

```plantext
    Объектно-ориентированное программирование (ООП) - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования
```

- [ООП](#ооп)
  - [Принципы ООП](#принципы-ооп)
    - [Инкапсуляция](#инкапсуляция)
    - [Наследование](#наследование)
    - [Полиморфизм](#полиморфизм)
    - [Абстракция (Дополнительный принцип)](#абстракция-дополнительный-принцип)
  - [Принципы SOLID](#принципы-solid)
  - [Пакеты и import](#пакеты-и-import)
  - [Синтаксис class](#синтаксис-class)
    - [Объявление класса](#объявление-класса)
    - [Поля класса](#поля-класса)
    - [Статические переменные и блоки](#статические-переменные-и-блоки)
    - [Конструкторы](#конструкторы)
    - [Константы](#константы)
    - [Метод `finalize()`](#метод-finalize)
  - [Наследование и Ключевое слово super](#наследование-и-ключевое-слово-super)
  - [Класс Object](#класс-object)
    - [Методы класса Object](#методы-класса-object)
    - [Реализация `equals` и `hashCode`](#реализация-equals-и-hashcode)
      - [Основные принципы реализации метода `equals`](#основные-принципы-реализации-метода-equals)
      - [Основные принципы реализации метода `hashCode`](#основные-принципы-реализации-метода-hashcode)
      - [Пример реализации `equals` и `hashCode`](#пример-реализации-equals-и-hashcode)
  - [Приведение типов (type casting)](#приведение-типов-type-casting)
    - [Пояснение механизма приведения типов](#пояснение-механизма-приведения-типов)
    - [Пример кода приведения типов](#пример-кода-приведения-типов)
    - [Восходящее преобразование](#восходящее-преобразование)
    - [Нисходящее преобразование](#нисходящее-преобразование)
    - [Ковариантность возвращаемых типов](#ковариантность-возвращаемых-типов)
  - [Перечисления](#перечисления)
  - [Интерфейсы](#интерфейсы)
  - [Функциональные интерфейсы](#функциональные-интерфейсы)
  - [Generics](#generics)

## Принципы ООП

ДОКУМЕНТАЦИЯ: <https://javarush.com/groups/posts/1966-principih-obhhektno-orientirovannogo-programmirovanija>

### Инкапсуляция

Имеет 2 трактовки:

1. `Инкапсуляция` - объединение в одном объекте данных и методов для работы с этими данными
2. `Инкапсуляция` - это сокрытие внутреней структуры объекта от внешнего мира. Все изменения состояния объекта происходят при помощи вызовов методов данного объекта

Данный принцип означает, что объект не должен изменяться ничем, кроме его собстенных методов, это позволяет избежать случайных взаимодействий и изменения полей в процессе работы объекта
К состоянию объекта имеет доступ только сам объект (состояние объекта - значение всех его полей)
*Например без инкапсуляции мы могли бы написать Cat.age = -1000;
Вывод: Необходимо скрывать внутренюю реализацию объекта от внешенго пользователя, стоит давать доступ только к основным методам данного класса

### Наследование

`Наследование` - механизм, который позволяет описать новый класс на основе существующего (родительского). При этом свойства и функциональность родительского класса заимствуются новым классом.

Наследование является формой отношение "Is a", т.е. одни класс является наследником другого калсса, например, круг является фигурой.

Наследование сужает класс родителя от общего описания до конкретной реализации, все круги являются фигурами, но не все фигуры являются кругами

**Наследование бывет двух типов**:

1. `Одиночное наследование`, когда один класс наследуется от одного другого
2. `Множественное наследование`, когда класс наследуется от нескольких других классов
   - В java множественное наследование разрешено только от определенного типа классов - [интерфейсов](#интерфейсы)

**Вывод**: Наследование приминяется в тех случаях, когда действительно выполнятеся отношение "Is a"(является), т.е. один объект является другим объектом

### Полиморфизм

`Полиморфизм` — это возможность работать с несколькими типами так, будто это один и тот же тип. При этом поведение объектов будет разным в зависимости от типа, к которому они принадлежат.

`Полиморфизм` - это возможность одного и того же алгоритма обрабатывать данные разных типов, независимо от того, какие это типы.
Без проверок типов внутри и ветвления в зависимости от того, с каким конкретным типом алгоритм работает в конкретный момент времени

Виды полиморфизма:

1. `ad-hoc (Полиморфизм по запросу)` - это создание видимости, что алгоритм полиморфный, но на самом деле в момент компиляции программы либо происходит подстановка другого алгоритма, в зависимости от типов переданных аргументов, либо происходит неявное преобразование типаов аргументов.
   - Примером является перегрузка функций/методов.
2. `Параметрический полиморфизм` - это возможность алгоритма работать с данными "не названных" типов, которым присвоены абстрактные имена.
   - Примером являются [Generics](#generics):
3. `Полиморфизм поддтипов` - это возможность алгоритма работать со всеми подтипами одного общего типа, опираясь на свойства общего базового класса. Наследование - это частный случай создания Подтипа
   - Похожей темой является [Восходящее преобразование](#восходящее-преобразование)

Польза полиморфизма:

1. Позволяет уменьшать размер пророгаммы, устранить повторяющийся код

Пример:

``` java
    // Полиморфизм: переменная типа Animal может ссылаться на объекты подклассов
    Animal myAnimal = new Animal(); 
    Animal myDog = new Dog();       
    Animal myCat = new Cat();       
```

### Абстракция (Дополнительный принцип)

Абстракция означает выделение главных, наиболее значимых характеристик предмета и наоборот — отбрасывание второстепенных, незначительных.

**Например**:

Скажем, мы создаем картотеку работников компании. Для создания объектов «работник» мы написали класс Employee. Какие характеристики важны для их описания в картотеке компании? ФИО, дата рождения, номер социального страхования, ИНН.
Но вряд ли в карточке такого типа нам нужны его рост, цвет глаз и волос. Компании эта информация о сотруднике ни к чему.

## Принципы SOLID

`SOLID` - это аббревеатура, которая описывает пять ключевых принципов проектирования объект-ориентированного кода:

1. `Принцип единой ответственности` (Single Responsibillity). Каждый класс должен выполнять одну поставленную ему задачу. Класс содержит единую логическую связанную функциональность. (Кофемашина только варит кофе, она не занимается кораской заборов)
2. `Принцип Открыто-закрыто` (Open-closed). Класс может предложить возможность расширения функциональности, однако он должен быть закрыт для изменения функцианальности. (Можно добавлять новый функционал, но нельзя изменять старый). Если при добавлении нового функционала необходимо менять исходный код уже написанных методо, то это нарушение метода
3. `Принцип подстановки Барбары Лисков` (Liskov Substitution). Производные классы только расширают функциональность исходного кода, не изменяя ее. Объекты в программе должны быть заменяемы на экземпляры их подтипов без изменения корректности работы. (Мы не можем менять логику работы предков, мы можем ее только дополнять)
4. `Принцип разделения инферфейсов` (Interface Segregation). Не стоит создавать слишком "толстые" интерфейсы. Клиенты не должны зависеть от интерфеса, который они не использую. (в интерфейсе должны быть описаны только методы, которые нужны для выполнения его задачи)
5. `Принцип инверисии зависимостей` (Dependency Inversion). Все зависимости в программе должны поддерживаться за счет абстрактных классов или интерфейсов. (Робот, которые режит пиццу не должен знать, каким инструментом оне режет, он должен просто выполнять работу конертным инструментом, который у него установлен)

## Пакеты и import

Классы, находящиеся в одном пакете могут обращаться друг к другу по короткому имени (file_name)
Если классы находятся в разных пакетах, то необходимо писать import `package_name.file_name`;
Для названия пакетов принято называть по доменному имени компании, продукта или проекта, в рамках которых был разработан данный пакет, например, `com.google.some_class`

```java
package [package_name]; // Помещает данный класс (файл) в одноименный пакет (задает область видимости класса)
// * Пишется в первой строчке программы
// ** При создании пакета основной файл прогрммы должен хранится по одноименному пути с названием пакета, например, [package_name]/[file_name].java

import [package_name].*; // импортировать все содержимое пакета
import static [package_name].[file_name]; // такой импорт позволяет обращаться к импортированному объекту без указания класса, например, import static java.lang.Math.sqrt; -> sqrt(4);
// * По большому счету import служит просто для более удобного обращения к другим классам, чтобы не писать их полное имя

// Классы-обертки и другие стандарные классы находятся в пакете java.lang. В каждой программе по умолчанию подразумеваестя import java.lang.*;
```

## Синтаксис class

### Объявление класса

```java
    public class ClassName {
        // Тело класса
    }
    // Модификаторы доступа (например, public, private, protected) определяют видимость класса для других частей программы
    // Ключевые слова классов могут включать final, если класс не должен наследоваться, или abstract, если класс не может быть создан напрямую
```

### Поля класса

```java
public int number = 10; // Поля объявляются внутри класса. Если значение не указано, будет использовано значение по умолчанию (для `int` это `0`, для объектов — `null` и т.д.)
private String name;
```

**this** используется для обращения к полям, если есть пересечение имен параметров метода и полей класса

Пример использования `this`:

```java
public class Example {
    private int number;

    public Example(int number) {
        this.number = number; // this используется для различения поля и параметра метода
    }
}
```

### Статические переменные и блоки

```java
public class StaticExample {
    // Статическая переменная
    static int i; // static — ключевое слово для объявления переменной, общей для всех экземпляров класса

    static { // Статические блоки выполняются один раз при загрузке класса
        i = 47; // Инициализация статической переменной
    }
}
```

### Конструкторы

Конструкторы вызываются при создании экземпляра класса с помощью оператора `new`.

Пример конструктора:

```java
public class ClassName {
    public ClassName(String param1) {
        // Логика конструктора
    }

    // Перегруженный конструктор с разными параметрами
    public ClassName(String param1, int param2) {
        // Логика конструктора
    }

    // Если нужно вызвать другой конструктор изнутри текущего, используется this()
    public ClassName() {
        this("param1", 0); // Вызов другого конструктора
    }

    private ClassName() { // Если требуется запретить создание экземпляров класса, делай конструктор private
        // Логика
    }
}
```

### Константы

```java
public static final int MAX_VALUE = 100; // Чтобы сделать поле неизменяемым, используй static final
```

### Метод `finalize()`

Метод `finalize()` вызывается перед удалением объекта сборщиком мусора. В современных версиях Java его использование не рекомендуется, но вот как он выглядит:

```java
@Override
protected void finalize() throws Throwable {
    try {
        // Очистка ресурсов
    } finally {
        super.finalize();
    }
}
```

## Наследование и Ключевое слово super

ДОКУМЕНТАЦИЯ: <https://javarush.com/groups/posts/1927-konstruktorih-bazovihkh-klassov-->

При переопределении методов внутри дочернего класса, ТИП возвращаемого значения должен совпадать или должен являться подклассом возвращаемого класса

- При выпонении таких условий дочерний класс в себе переопределит метод родительского класса

При наследовании одного класса от другого сначала вызывается конструктор класса-родителя, а только потом наследника

- Если в консрукторе класса есть параметры, то необходимо воспользоваться super

При создании сложного объекта с множественным наследованием, конструкторы объектов вызываются в следующей последовательности:

1. Сначала выделяется память под объекты класса и запоняется нулями
2. Сначала вызывается конструктор базового класса, это повторяется рекурсивно вполоть до Object
3. Проводится инициализация полей класса в порядке их объявления
4. Вызывается конструктор производного класса
   - При переопределении метода базового класса, который вызывается в конструкторе базового класса, будет вызван переопределенный метод
   - !Единственные методы, которые можно вызывать в конструторе без опаски - это private и final методы!

```java
class [ChildName] extends [ParentName] // Наследование одного класса от другого
// * Наследоваться можно только от одного класса
// * При наследовании все поля и методы одного класса переходят к другому классу

super // Cсылка на класс, от которого наследовался дочерний класс
super(param1, param2) // Вызов конструктора класса-родителя
// * При данном вызове будут заполнены поля дочернего класса при помощи родителя, это будет актульно только для полей, не переопределенных в дочернем классе
// * Всегда идет перед другим кодом в конструкторе
// ** Если конструктор класса родителя имеет аргументы то вызов super(param1, param2) строго обязателен при инициализации дочернего класса
super.[name]() // Вызов метода родительского класса (работает даже при переопределении метода)
// Наследование не должно противоречить поведению, заданному базовым классом
```

## Класс Object

Класс `Object` в Java **является родительским для всех классов**. Это значит, что каждый класс в Java неявно наследует методы из класса Object, если не указано иное. Рассмотрим методы, определенные в классе Object:

`ДОКУМЕНТАЦИЯ`: <https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html>

### Методы класса Object

```java
    public final Class<?> getClass(); // Возвращает объект класса `Class`, который представляет класс или интерфейс, к которому принадлежит этот объект во время выполнения
    public int hashCode(); // Возвращает хеш код данного объекта (нужно для размещения объектов в хеш таблицах)
    public boolean equals(Object obj); // Сравнивает этот объект с указанным объектом для проверки равенства
    //   * Обязательное требование к реализации: если объекты равны в equals(), то у них должны быть равны hashCode(). Если данное правило нарушается, то эти объекты нельзя хранить в хеш таблицах
    protected Object clone() throws CloneNotSupportedException; // Создает и возвращает копию этого объекта. Для этого метода класс должен реализовать интерфейс `Cloneable`
    public String toString(); // Возвращает строковое представление объекта (по умолчанию это строка типа: [ИмяКласса]@[16-ричный хеш код])
    //  * Если переопределить данный метод в дочерних класса, то он будет вызываться при попытке перевести новый класс в строку
    public final void notify(); // Пробуждает один поток, который ждет на мониторе этого объекта
    public final void notifyAll(); // Пробуждает все потоки, которые ждут на мониторе этого объекта
    public final void wait() throws InterruptedException; // Заставляет текущий поток ожидать, пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта
    public final void wait(long timeout) throws InterruptedException; // Заставляет текущий поток ждать до тех пор, пока не истечет указанный период времени в миллисекундах, если другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта
    public final void wait(long timeout, int nanos) throws InterruptedException; // Заставляет текущий поток ждать до тех пор, пока не истечет указанный период времени в миллисекундах плюс дополнительные наносекунды, если другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта
    protected void finalize() throws Throwable; //  Вызывается сборщиком мусора, когда больше нет ссылок на объект. Обычно используется для освобождения ресурсов перед уничтожением объекта
```

### Реализация `equals` и `hashCode`

Реализация методов `equals` и `hashCode` является важной задачей при создании собственных классов в Java. Эти методы используются, например, в коллекциях, таких как HashMap, HashSet и других. Правильная реализация этих методов позволяет корректно сравнивать объекты и эффективно использовать их в хэш-структурах данных.

#### Основные принципы реализации метода `equals`

1. `Рефлексивность`: для любого ненулевого значения x, x.equals(x) должно возвращать true.
2. `Симметричность`: для любых ненулевых значений x и y, x.equals(y) должно возвращать true тогда и только тогда, когда y.equals(x) также возвращает true.
3. `Транзитивность`: для любых ненулевых значений x, y и z, если x.equals(y) возвращает true и y.equals(z) возвращает true, то x.equals(z) должно также возвращать true.
4. `Согласованност`ь: для любых ненулевых значений x и y, многократные вызовы x.equals(y) должны возвращать одно и то же значение, если только не изменились значения, участвующие в сравнении.
5. `Ненулевое значение`: для любого ненулевого значения x, x.equals(null) должно возвращать false.

#### Основные принципы реализации метода `hashCode`

1. `Согласованность`: если equals двух объектов возвращает true, их hashCode должны быть одинаковыми.
2. `Стабильность`: многократные вызовы метода hashCode на одном и том же объекте должны возвращать одно и то же значение, пока значения объекта не изменяются.

#### Пример реализации `equals` и `hashCode`

```java
    import java.util.Objects;

    public class Person {
        private int id;
        private String name;
        private int age;

        @Override
        public boolean equals(Object o) {
            if (this == o) return true; // Проверяем, не сравниваем ли мы объект сам с собой (рефлексивность)
            if (o == null || getClass() != o.getClass()) return false; // Проверяем, не является ли сравниваемый объект null и принадлежит ли он тому же классу
            Person person = (Person) o; // Конвертирует объект в нужный нам класс
            return id == person.id && age == person.age && Objects.equals(name, person.name); // Сравниваем значимые поля. В данном случае, поля id, name и age
        }

        @Override
        public int hashCode() {
            return Objects.hash(id, name, age); // Используем метод Objects.hash, который принимает любое количество аргументов и возвращает их хэш-код.
        }
        /* Тонкости и советы:
            Использование полей: Включайте в методы equals и hashCode только те поля, которые определяют уникальность объекта.
            Производительность: Поля, которые часто изменяются, лучше не включать в hashCode, так как это может привести к снижению производительности в коллекциях.
        */
    }
```

## Приведение типов (type casting)

В Java приведение объекта к другому типу (кастинг) работает на основе системы типов и наследования. В строке `Person person = (Person)obj;` происходит так называемое "приведение типов" (type casting), и программа проверяет тип объекта во время выполнения (runtime).

### Пояснение механизма приведения типов

1. `Компиляция и проверка типов`**`:
   - На этапе компиляции компилятор проверяет, является ли приведение типов допустимым. В данном случае, компилятор знает, что `obj` имеет тип `Object`, который является родительским классом для всех объектов в Java, включая `Person`.

2. `Проверка времени выполнения (Runtime check)`:
   - Во время выполнения программы, когда строка `Person person = (Person)obj;` исполняется, Java Virtual Machine (JVM) проверяет фактический тип объекта, на который ссылается `obj`.
   - Если `obj` действительно указывает на объект класса `Person`, приведение типов будет успешным, и переменная `person` будет ссылаться на этот объект. Если объект, на который ссылается `obj`, не является экземпляром `Person` или его подкласса, будет выброшено исключение `ClassCastException`.

### Пример кода приведения типов

```java
    public class Main {
        public static void main(String[] args) {
            Object obj1 = new Person(1, "John", 25); // Переменная `obj1` ссылается на объект класса `Person`
            Object obj2 = new String("Hello"); // Переменная `obj2` ссылается на строку (экземпляр класса `String`)

            // Пример успешного приведения типов
            if (obj1 instanceof Person) { // Проверяет, является ли `obj1` экземпляром класса `Person`
                Person person1 = (Person) obj1; // Приведение типов успешно
                System.out.println(person1.getName()); // John
            }

            // Пример неуспешного приведения типов
            if (obj2 instanceof Person) { //  Проверяет, является ли `obj2` экземпляром класса `Person`
                Person person2 = (Person) obj2; // Приведение типов неудачно, этот код не выполнится
                System.out.println(person2.getName());
            } else {
                System.out.println("obj2 не является экземпляром Person");
            }
        }
    }

    class Person {
        private int id;
        private String name;
        private int age;

        public Person(int id, String name, int age) {
            this.id = id;
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }
    }
```

**Выводы**\
Приведение типов в Java основывается на информации о типах, доступной во время компиляции, и на проверке фактического типа объекта во время выполнения. Использование оператора `instanceof` позволяет безопасно выполнять приведение типов, предотвращая `ClassCastException` и обеспечивая корректную работу программы.

### Восходящее преобразование

`Восходящее преобразование` - процесс преобразования объекта от дочернего класса к родительскому

```java
    Share s = new Circle();
    // * Объект Circle является дочерним классом от Share, поэтому преобразование уместно
    // * При подобном преобразовании новые методы класса Circle будут проигнорированны, будет учитываться только интерфес класса Share
    // * Если переопределить метод в Circle, который есть в Share, то при восходящем приобразовании переопределенный метод останится у нового объекта
    // ** Данное преобразование справедливо при передаче объектов в функцию, например: в square(Share s) можно спокойно передать объект Circle
    // ** Статические методы не поддерживают полиморфного поведения и не переопределются при восходящем приобразовани, так как определяются на уровне класса
```

### Нисходящее преобразование

`Нисходящее преобразование` - процесс преобразования объекта от родительского класса к дочернему

```java
    Ex ex = new Ex_2();
    (Ex_2)ex // Пример нисходящего преобразования
    // !Небезопасная операция!
```

### Ковариантность возвращаемых типов

Ковариантность типов означает, что переопределенный метод прозводного класса может вернуть тип, производный (является наследником базового типа) от типа, возвращаемого методом базового класса

## Перечисления

`ДОКУМЕНТАЦИЯ`: <https://javarush.com/groups/posts/1963-kak-ispoljhzovatjh-klass-enum>

```java

    public enum EnumName { // Enum — это класс с фиксированным набором значений, который ты можешь использовать для объявления ограниченного набора варианто
        CONSTANT1, // 0
        CONSTANT2, // 1
        CONSTANT3; // 2
    }

    public enum Day {
        MONDAY("Понедельник"), // Конструктор перечисления вызывается для каждого элемента, и в него передаётся соответствующее значение
        TUESDAY("Вторник"),
        WEDNESDAY("Среда");

        private final String russianName; // Cвязывает каждое значение перечисления с его русским названием

        // Конструктор перечисления
        Day(String russianName) {
            this.russianName = russianName;
        }

        // Метод для получения русского названия
        public String getRussianName() {
            return russianName;
        }
    }

    enumName[] paramArray = enumName.values(); // Возвращает массив перечисления в том же порядке
    String paramName = paramName1.name(); // Возвращает имя элемента как в исходном коде
    int paramNumber = paramName1.ordinal(); // Возвращает номер элемента в последовательсности объявлений, начиная с 0
```

## Интерфейсы

ДОКУМЕНТАЦИЯ: <https://javarush.com/groups/posts/1981-dlja-chego-v-java-nuzhnih-interfeysih>

```java
   public interface InterfaceName {
    // Поля интерфейса всегда публичные, статические и финальные (по умолчанию public static final)
    int CONST = 10; // Поле-константа, должно быть проинициализировано
    int CONST_2 = sum(1, 2); // Инициализация поля через метод

    // Метод интерфейса без реализации
    int div(int a, int b); // Методы в интерфейсе по умолчанию имеют модификаторы public и abstract, так что их можно не указывать

    // Интерфейсы могут содержать методы с реализацией по умолчанию с использованием ключевого слова default. Если класс не переопределяет такой метод, используется стандартная реализация
    default void print(String str) {
        System.out.println(str);
    }
}
```

**Реализация интерфейсов**:

```java
    public class Calculator implements InterfaceName1, InterfaceName2 { // Ключевое слово implements используется для указания, что класс реализует интерфейс
    //  * Можно реализовать несколько интерфейсов через запятую
        @Override
        public int div(int a, int b) {
            if (b == 0) {
                throw new IllegalArgumentException("Division by zero");
            }
            return a / b;
        }
    }
```

**Пример реализации**:

```java
    public interface Vehicle {
        void move();
    }

    public interface Electric {
        default void charge() {
            System.out.println("Charging...");
        }
    }

    public class ElectricCar implements Vehicle, Electric {
        @Override
        public void move() {
            System.out.println("The electric car is moving.");
        }
    }

    public class Main {
        public static void main(String[] args) {
            ElectricCar tesla = new ElectricCar();
            tesla.move(); // Output: The electric car is moving.
            tesla.charge(); // Output: Charging...
        }
    }
```

## Функциональные интерфейсы

`Функциональные интерфейсы` - интерфейсы, которые имеют один абстрактный метод, который можно переопределить

Функциональные интерфейсы: <https://javarush.com/groups/posts/2866-funkcionaljhnihe-interfeysih-v-java>

```java
    @FunctionalInterface // Специальная аннотация, которая позволяет понять компилятору, кто интерфейс функциональный
    // * При этом дефолтные методы и ститические методы не идут в счет
    
    // Встроенные функциональные интерфейсы: <https://metanit.com/java/tutorial/9.3.php>

    Predicate<T> // Проверяет соблюдение некоторого условия. Если оно соблюдается, то возвращается значение true.
    public interface Predicate<T> {
        boolean test(T t);
    }

    Consumer<T>  // Выполняет некоторое действие над объектом типа T, при этом ничего не возвращая
    public interface Consumer<T> {
        void accept(T t);
    }

    Function<T,R> // Представляет функцию перехода от объекта типа T к объекту типа R
    public interface Function<T, R> {
        R apply(T t);
    }

    Supplier<T> // Не принимает никаких аргументов, но должен возвращать объект типа T
    public interface Supplier<T> {
        T get();
    }

    UnaryOperator<T> // Принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T
    public interface UnaryOperator<T> {
        T apply(T t);
    }

    BinaryOperator<T> // Принимает в качестве параметра два объекта типа T, выполняет над ними бинарную операцию и возвращает ее результат также в виде объекта типа T
    public interface BinaryOperator<T> {
        T apply(T t1, T t2);
    }
    // ** !!!Функциональные интерфейсы нужны чтобы реализовывать lambda функции!!!
```

## Generics

`Generics` - позволяют параметризовать функцию - добавить параметр, который можно использовать в функции (при этом параметр должен удволетворять какому то условию)

`ДОКУМЕНТАЦИЯ`: <https://javarush.com/groups/posts/2004-teorija-dzhenerikov-v-java-ili-gde-na-praktike-stavitjh-skobki>

```java
    //  ** В параметризации могут искользоваться только #Ссылочные типы#:
    //  * Если не указать параметр при инициализации, то будет подставлен Object

    Параметризованные классы

    public class [ClassName]<T extends ClassOrInterfaceName & InterfaceName & ... > {...} // код создания параметризованного класса
    //  * <T> - название параметра
    //  * extends позволяет установить ограничения на тип параметра
    //  ** Параметр исопльзуется вместо типа данных данных:
    public T get(); // T указывает на тип возвращаемого значения функции
    //  ** Статические методы параметризовать нельзя
    ClassName<String> ex = new ClassName<>(); // Пример объявления параметризованного класса
    
    // Ограничение типа (Type Bound)

    <T extends Number> // Ограничение типа позволяет указать, что обобщенный тип должен быть конкретным типом или его подтипом 
    // Кострукции <T super Number> не существует!

    // Wildcard - Помогают создавать более гибкие и переиспользуемые методы и классы
    // ДОКУМЕНТАЦИЯ: https://docs.oracle.com/javase/tutorial/java/generics/unboundedWildcards.html

    <?> // Неограниченный wildcard - означает любой тип
    <? super T> // Wildcard с нижней границей - передаваемый тип ? должен быть родителем для класса T
    //  * Нужно использовать, когда мы отдаем данные куда то
    <? extends T> // Wildcard с верхней границей - передаваемый тип ? должен быть наследником для класса T (так, например Integer является подтипом Number)
    //  * Нужно использовать, когда мы получаем данные от куда то
```
