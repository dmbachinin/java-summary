# Типы данных

- [Типы данных](#типы-данных)
  - [Примитивные типы](#примитивные-типы)
    - [Var](#var)
    - [Ссылочные типы](#ссылочные-типы)
    - [Строки](#строки)
    - [Форматирование](#форматирование)
    - [Регулярные выражения](#регулярные-выражения)
  - [Сравнение строк](#сравнение-строк)
  - [Массивы](#массивы)
    - [Сравнения массивов](#сравнения-массивов)
    - [Arrays](#arrays)
    - [Основные методы класса `Arrays`](#основные-методы-класса-arrays)
      - [1. Сортировка](#1-сортировка)
      - [2. Поиск](#2-поиск)
      - [3. Сравнение](#3-сравнение)
      - [4. Копирование](#4-копирование)
      - [5. Заполнение](#5-заполнение)
      - [6. Преобразование](#6-преобразование)
      - [7. Параллельные операции](#7-параллельные-операции)
  - [Классы-обертки](#классы-обертки)
  - [Преобразования типов](#преобразования-типов)
  - [Автоматическое расширение](#автоматическое-расширение)

## Примитивные типы

`Примитивные типы` - это типы данных, которые непосредственно записываются в память

- `boolean` - логический тип
- `char` - символьный тип (число от 0 до 2^16) - хранит номер в символа в кодировке Unicode (с данным типом - данных доступны #Побитовые операции#)
- `char` literal = 'a'; - запись одного сивола происходит при помощи одинарных ковычек
- `char hex` = '\u03A9' - запись любого символа при помощи номера юникод
- `byte`(1 байт), `short`(2 байта), `int`(4 байта), `long`(8 байт) - целочисленные типы, которые отличаются емкостью

```java
    int decimal = 99; // число в десятичной системе счисления(10)
    int octal = 0755; // число в восьмеричной системе счисления(8)
    int hex = 0xFF; // число в шестнадцатеричной системе счисления(16)
    int binary = 0b101; // число в двоичной системе счисления(2)
    int tenMillion = 10_000_000; // в записи числа можно испольщовать _ для улучшения читабельности
    long tenBillion = 10_000_000_000L; // если число не помещается в int, то ему необходимо добавить "L", чтобы сказть компилятору, что число long
    float (32 бита), double (64 бита) // вещественные типы, которые отличаются емкостью
    //  * Диапозон значений вещественных типов определяется по формуле +-m*2^e, где m - мантисса (у float = 23, у double = 52), e - экспонента (у float = 8, у double = 11). 1 Бит выделяется под знак
    double simple = -1.234; // стандарная запись вещественного числа
    double exponential = -123.4e-2; // эксоненциальная запись вещественного числа = -123,4 * 10^-2 (e-n = 10^-n)
    double hex = 0x1.Fp10; // эксоненциальная запись шестнадцатеричного числа = 1.F * 2^10 (pn = 2^n)
    float floatWithSuffix = 36.6f; // все вещественные числа по умолчанию имеют тип double, для преобразования его во float необходимо дописать суффикс f
    double doubleWithSuffix = 4d; // суффикс для явного указания на тип double
    //  ** Поддерживают #Арифметические операции# но не #Побитовые операции#
    // Особые случаи:
    double positivelInfinify = 1.0 / 0.0; // -> +inf(беспонечность) // любые опрерации над inf будут иметь смысл, например, 1 + inf = inf
    double negativeInfinify = -1.0 / 0.0; // -> -inf(беспонечность)
    double nan = 0.0 / 0.0; // -> nan (Not a Number). nan != nan -> true
    // ** Для сравнения вещественных чисел используют конструкцию |a - b| < E (E - точность)
```

### Var

В Java ключевое слово `var` было введено в версии Java 10 и предназначено для локальной типизации переменных. Это означает, что компилятор Java может выводить тип переменной из инициализирующего выражения. Использование var упрощает код, делая его более читаемым и менее многословным, особенно при использовании сложных типов.

Основные моменты, которые следует учитывать:

1. `Только для локальных переменных`: var может использоваться только для локальных переменных внутри методов, конструкций циклов, инициализации и блоков инициализации. Его нельзя использовать для полей класса, параметров методов или возвращаемых типов методов.
2. `Явная инициализация`: Переменная, объявленная с помощью var, должна быть инициализирована в момент объявления, чтобы компилятор мог вывести тип.
3. `Читаемость кода`: Хотя var может упростить синтаксис, важно использовать его с осторожностью, чтобы не ухудшить читаемость кода. Например, в случаях, когда тип не очевиден, лучше явно указать его.

Пример

```java
var message = "Hello, World!"; // Компилятор выводит тип String
var user = new User("John", "Doe"); // Компилятор выводит тип User

var value;  // Ошибка: переменная должна быть инициализирована
```

### Ссылочные типы

`Ссылочные типы` - это тип данных, в память записывается ссылка на адрес, содержащий ссылку на сам объект в памяти

- Любой переменной данного типа можно присвоить null

### Строки

Строки являются неизменяемым типом данных

```java
    String str = "Hi"; // строка
    char[] charArray = str.toCharArray(); // преобразование строки в массив символов
    int length = str.length(); // получение длины строчки
    char charAtIdx = str.charAt([idx]); // получение символа по индексу
    boolean startWithTable = str.endsWith("[String]"); // начинается ли строка на [String]
    boolean endsWithTable = str.endsWith("[String]"); // заканчивается ли строка на [String]
    boolean isContains = str.contains("[String]"); // есть ли строка [String] в str
    String concatStr = str.concat("[String]"); // конкатинация (соединение) 2-х строк
    String substring = str.substring([start_idx], [end_idx]); // вырезать подстроку из строки от start_idx до end_idx (не включительно)
    String[] strArray = str.split("[reg]", int limit); // разделение строки по шаблону limit раз
    String afterReplace = str.replace("[Old String]", "[new String]"); // заменить все подстроки на другие
    String allCapitals = str.toUpperCase(); // перевод строки в заглавному регистру
    String allSmall = str.toLowerCase(); // перевод строки к строчному регистру
    String regString = str.replaceAll("[reg]", "[String]"); // заменить фрагменты строки, которые подходят по регулярному выражению
    * [^a-zA-Z0-9] // шаблон описывает латинские символы без учета регистра
    int position = str.indexOf(ch) // возавращает позицию первого вхождения символа в строку
    int position = str.lastIndexOf(ch) // возавращает позицию последнего вхождения символа в строку

    StringBuilder sb = new StringBuilder("[start String]"); // создание объекта StringBuilder, который похож на строку, но допускает изменение содержимого
    // ДОКУМЕНТАЦИЯ: https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/StringBuilder.html#capacity()
    sb.append("[String]"); // добавление строки [String] в последовательность StringBuilder
    sb.delete([start_idx], [end_idx]) // удаление подстроки из строки
    sb.indexOf("[String]", [idx]); // возвращает индекс в этой строке первого вхождения указанной подстроки, начиная с указанного индекса (если idx указан)
    sb.insert([element], [idx]); // втавляет указанный элемент в указанное место
    sb.length() // возвращает длину (количество символов)
    sb.reverse() // обратное отражение последовательности
    String str = sb.toString(); // перевод объекта StringBuilder в String
```

### Форматирование

ДОКУМЕНТАЦИЯ: <https://rukovodstvo.net/posts/id_590/>

```java
    System.out.printf("%[спецификатор типа]", args);
    String s = String.format("%[спецификатор типа]", args); форматирование строки и возвращение результата

    Спецификаторы типов:
    %c - символ
    * Можно указывать в виде "{code Point}"(например, "0x11FFFF")
    %d - десятичное число (основание 10)
    %i - целое число (основание 10)
    %o - восьмеричное число (основание 8)
    %u - беззнаковое десятичное (целое) число
    %x - шестнадцатеричное число (основание 16)
    %e - экспоненциальное число с плавающей запятой
    %f - число с плавающей запятой
    %s - Строка
    %t - Дата / время
    %te - день из даты
    %tm - месяц из даты
    %tY - год в формате 3-х цифр
    %n - Новая строка

    Инструкции спецификатора:
    %[аргумент_индекс][флаги][ширина][.точность][спецификатор типа] - шаблон инструкции для спецификатор

    [аргумент_индекс] — целое число, указывающее позицию в списке аргументов. К примеру, ссылка на первый аргумент 1$, ссылка на второй аргумент — 2$, и т.д.
    Если же позиция не была задана, аргументы должны находиться в том же порядке, что и ссылки на них в строке форматирования.
    [флаги] — специальные символы для форматирования. Например:
    + флаг, означающий, что если числовое значение положительное, оно должно включать знак +
    - означает выравнивание результата по левому краю
    , устанавливает разделитель тысяч у целых чисел
    [ширина] — положительное целое десятичное число, определяющее минимальное количество символов, которые будут выведены. Если перед этим числом стоит 0, то недостающие символы будут дополнены 0, если 0 нет, то пробелами.
    [.точность] — неотрицательное целое число с точкой перед ним. Как правило используется для ограничения количества символов. Специфика поведения зависит от конкретного вида спецификатора.

    Примеры:
    String s = String.format("%2$s, %1$s", "str1","str2"); - обращение к разным элементам по индексу
    * Вывод: "str2, str1"
    String s = String.format("%1$+09.5f", 3.1415926535897);
    * Вывод: +03,14159

    Форматирование чисел
    DecimalFormat — класс для форматирования любого числа в Java, будь то целое число или число с плавающей запятой
    String s = new DecimalFormat( "[шаблон]" ).format(Number)

    Элементы для написания шаблонов:
    [ — цифра, ведущие нули опускаются
    0 — цифра отображается всегда, даже если в номере меньше цифр (в таком случае отображается 0)
    . — знак десятичного разделителя
    , — знак группировки разделителей (например, разделитель тысяч)
    ; — разделяет форматы
    - — отмечает префикс отрицательного числа
    % — умножает на 100 и показывает число в процентах
    ? — умножает на 1000 и показывает число в промилле
    E — разделяет мантиссу и порядок для экспоненциального формата

    Примеры:
    System.out.println(new DecimalFormat( "###,###.##" ).format(74554542.224463));
    * Вывод: 74 554 542,22
    System.out.println(new DecimalFormat( "%###.##" ).format(0.723456));
    * Вывод: %72,35
    System.out.println(new DecimalFormat( "000.###" ).format(42.224463));
    * Вывод: 042,224

    ** При обрезании числа со знаками после запятой, выходящими за заданный шаблон,
    DecimalFormat округляет число в большую сторону, если последнее обрезаемое число больше 5.
```

### Регулярные выражения

ДОКУМЕНТАЦИЯ: <https://javarush.com/groups/posts/regulyarnye-vyrazheniya-v-java>

```java
    Pattern pattern = Pattern.compile("[RegEx]", int flags); - компиляция шаблона регулярного выражения
    * flags - определяет дополнительные возможности для регулярного выражения
    Pattern.CANON_EQ - обеспечивает каноническую эквивалентность
    Pattern.CASE_INSENSITIVE - включает сопоставление без учета регистра
    Pattern.COMMENTS - разрешает пробелы и комментарии в шаблоне

    Метасимволы для поиска совпадений границ строк или текста:
    ^ - начало строки
    $ - конец строки
    \b - граница слова
    \B - не граница слова
    \A - начало ввода
    \G - конец предыдущего совпадения
    \Z - конец ввода
    \z - конец ввода

    Метасимволы для поиска символьных классов:
    \d - цифровой символ
    \D - нецифровой символ
    \s - символ пробела
    \S - непробельный символ
    \w - буквенно-цифровой символ или знак подчёркивания
    \W - любой символ, кроме буквенного, цифрового или знака подчёркивания
    . - любой символ

    Метасимволы для поиска символов редактирования текста:
    \t символ табуляции
    \n символ новой строки
    \r символ возврата каретки
    \f переход на новую страницу

    Метасимволы для группировки символов:
    [абв] - любой из перечисленных (а,б, или в)
    [^абв] - любой, кроме перечисленных (не а,б, в)
    [a-zA-Z] - слияние диапазонов (латинские символы от a до z без учета регистра )
    [a-d[m-p]] - объединение символов (от a до d и от m до p)
    [a-z&&[def]] - пересечение символов (символы d,e,f)
    [a-z&&[^bc]] - вычитание символов (символы a, d-z)

    Метасимволы для обозначения количества символов – квантификаторы.
    * Квантификатор всегда следует после символа или группы символов.
    ? - один или отсутствует
    * - ноль или более раз
    + - один или более раз
    {n} - n раз
    {n,} - n раз и более
    {n,m} - не менее n раз и не более m раз

    **Режимы квантификаторов:
    [квантификатор] - жадный режим (обычный) - находит максимально большое совпадение
    [квантификатор]+ - сверхжадный режим - находит максимально большое совпадение, которое должно заканчиваться в конце строки
    [квантификатор]? - ленивый режим - находит самые первые совпадения
```

## Сравнение строк

```java
    boolean referenceEquals = str1 == (str2); // сравнивает ссылки двух переменных, а не содержимое
    boolean contetEquals = str1.equals(str2); // сравнение двух строк по содержимому
    boolean contetEqualsIgnoreCase = str1.equalsIgnoreCase(str2); // сравнение содержимого строк, игнорируя регистр
```

## Массивы

```java
    [type][] [name]; // объявление массива определенных данных
    int[] numbers = new int[len] // создает массив целых чисел размера len
    boolean bools[] = new boolean[len] // альтернативные способ создания массива
    * При инициализации массив заполняется значениями по умолчанию (int -> 0, boolean -> false, Ссылки -> null)
    ** Размер массива изменить нельзя
    Object[] objectArr = new Object[]{new Integer(1), new Float(2.3)} // пример создания массива объектов, в который можно положить любые объекты

    int[] numbers = new int[] {1,2,3,4,5}; // задание массива с заполнением
    * Данная запись позволяет создать заполненный массив где угодно, например, при передаче параметра в функцию
    int[] numbers = {1,2,3,4,5}; // краткая форма задания массива с заполнением (работает, если переменная объявляется и инициализируется в одной строчке)

    int len = numbers.length; // получение длины массива
    int element = numbers[id]; // получение элемента по id

    int[][] matrix = new int[len][len]; // объявление двумерного массива
    int[][] matrix = {{1,2},{3,4,5}, null, {6}}; // альтернативное объявление двумерного массива (можно задать произвольный размер для вложенных массивов)
```

### Сравнения массивов

```java
    int[] a = {1,2,3}; int[] b = {4,5,6}; // объявление массивов
    a == b; // оператор сравнивает ссылки объектов, т.е. ссылаются ли переменные на один и тот же объект
    Arrays.equals(a, b); // сравнение массивов по содержимому (на первом уровне вложенности)
    Arrays.deepEquals(matrix1, matrix2); // сравнение массивов по содержимому (на всех уровнях вложенности)
    Arrays.toString(a); // преобразование массива в строку (на первом уровне вложенности)
    Arrays.deepToString(matrix); // преобразование массива в строку (на всех уровнях вложенности)
    * import java.util.Arrays; // импорт класса Arrays(очень полезный класс для работы с массивами)
```

### Arrays

Класс `Arrays` в Java находится в пакете java.util и предоставляет множество статических методов для работы с массивами. Эти методы включают сортировку, поиск, сравнение, копирование и преобразование массивов. Класс Arrays облегчает манипуляции с массивами, делая код более компактным и удобочитаемым.

ДОКУМЕНТАЦИЯ: [Arrays](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Arrays.html)

Класс `Arrays` в Java находится в пакете `java.util` и предоставляет множество статических методов для работы с массивами. Эти методы включают сортировку, поиск, сравнение, копирование и преобразование массивов. Класс `Arrays` облегчает манипуляции с массивами, делая код более компактным и удобочитаемым.

### Основные методы класса `Arrays`

#### 1. Сортировка

```java
    static void sort(int[] a); // Сортирует массивы в порядке возрастания
    static void sort(double[] a);
    static void sort(Object[] a);
    static <T> void sort(T[] a, Comparator<? super T> c);

    int[] arr = {3, 1, 4, 1, 5};
    Arrays.sort(arr);
    System.out.println(Arrays.toString(arr));  // [1, 1, 3, 4, 5]
```

#### 2. Поиск

```java
    static int binarySearch(int[] a, int key); // Выполняет бинарный поиск в отсортированном массиве
    static int binarySearch(double[] a, double key);
    static <T> int binarySearch(T[] a, T key, Comparator<? super T> c);

    int[] arr = {1, 2, 3, 4, 5};
    int index = Arrays.binarySearch(arr, 3);
    System.out.println(index);  // 2
```

#### 3. Сравнение

```java
    static boolean equals(int[] a, int[] a2); // Сравнивает два массива на равенство
    static boolean equals(double[] a, double[] a2);
    static boolean equals(Object[] a, Object[] a2);

    int[] arr1 = {1, 2, 3};
    int[] arr2 = {1, 2, 3};
    boolean areEqual = Arrays.equals(arr1, arr2);
    System.out.println(areEqual);  // true
```

#### 4. Копирование

```java
    static int[] copyOf(int[] original, int newLength); // Копирует массив в новый массив указанной длины
    static double[] copyOf(double[] original, int newLength);
    static <T> T[] copyOf(T[] original, int newLength);

    int[] arr = {1, 2, 3};
    int[] newArr = Arrays.copyOf(arr, 5);
    System.out.println(Arrays.toString(newArr));  // [1, 2, 3, 0, 0]

    static int[] copyOfRange(int[] original, int from, int to); // Копирует диапазон из одного массива в новый массив от индекса from до to(исключительно)
    static double[] copyOfRange(double[] original, int from, int to);
    static <T> T[] copyOfRange(T[] original, int from, int to);

    int[] arr = {1, 2, 3, 4, 5};
    int[] newArr = Arrays.copyOfRange(arr, 1, 4);
    System.out.println(Arrays.toString(newArr));  // [2, 3, 4]
```

#### 5. Заполнение

```java
    static void fill(int[] a, int val) // Заполняет массив указанным значением
    static void fill(double[] a, double val);
    static void fill(Object[] a, Object val);

    int[] arr = new int[5];
    Arrays.fill(arr, 1);
    System.out.println(Arrays.toString(arr));  // [1, 1, 1, 1, 1]
```

#### 6. Преобразование

```java
    static String toString(int[] a); // Возвращает строковое представление массива
    static String toString(double[] a);
    static String toString(Object[] a);

    int[] arr = {1, 2, 3};
    String arrStr = Arrays.toString(arr);
    System.out.println(arrStr);  // [1, 2, 3]

    static <T> List<T> asList(T... a); // Преобразует массив в список фиксированной длины
    String[] arr = {"A", "B", "C"};
    List<String> list = Arrays.asList(arr);
    System.out.println(list);  // [A, B, C]
```

#### 7. Параллельные операции

```java
static void parallelSort(int[] a); // Сортирует массив параллельно
static void parallelSort(double[] a);
static <T> void parallelSort(T[] a, Comparator<? super T> c);

int[] arr = {5, 3, 8, 1, 2};
Arrays.parallelSort(arr);
System.out.println(Arrays.toString(arr));  // [1, 2, 3, 5, 8]
```

## Классы-обертки

Классы-обертки:

- это двойнеки для примитивных типов, но они являются ссылочными типами (классами)
- Полезны, чтобы хранить значения в коллекции
ДОКУМЕНТАЦИЯ: <https://javarush.com/groups/posts/1948-objertki-raspakovka-i-zapakovka>

Примеры классов-оберток:

- boolean -> Boolean
- byte -> Byte
- short -> Short
- int -> Integer
- long -> Long
- char -> Character
- float -> Float
- double -> Double

```java

    Integer.parseInt("[String]" int radix); // Преобразует строку в число, radix указывает систему счисления (до 36 включительно),  в какой системе счисления изначально записано число в String
    Integer.toBinaryString(int А); // Преобразование числа в двоичный код
    Integer.bitCount(int А); //  Считает количестов бит = 1 в числе


    // Методы для классов-оберток:
    [класс-обертка].valueOf(T A); // Привести переменную из приметивного типа в обертку (boxing)
    Double.parseDouble("1.2"); // Преобразует строку в определенный type
    [класс-обертка].toString(T A); // Преобразование А в строку
    int = A.IntegerValue(); // Преобразование переменной А из класса-обертки в приметивный тип (unboxing)

    // Полезные методы:

    short maxShortValue = Short.MAX_VALUE; // Возвращает максимальное значение для данного примитива
    short minShortValue = Short.MIN_VALUE; // Возвращает минимальное значение для данного примитива
    boolean isLetter = Character.isLetter('a'); // Проверяет, совпадают ли данные символы
    float floatInfinity = Float.POSITIVE_INFINITY; // Возвращает +inf c типом float
    double doubleNaN = Double.NaN; // Пустое значение double
    boolean isNaN = Double.isNaN(doubleNaN); // Проверка на Double.NaN значение
```

## Преобразования типов

```java
    double pi = Math.PI;
    int intPi = (int) pi; // Преобразование одного типа в другой
```

## Автоматическое расширение

`Автоматическое расширение` - приведение аргументов к одному типу при выполнении операций

```java
    double doubleValue = 1d + 1f; // Eесли одно из значений double, то все остальные переменные тоже приводятся к double
    float floatValue = 1f * 1; // Eсли одно из значений float, то все остальные переменные тоже приводятся к float
    long longValue = 1L - 'O'; // Eсли одно из значений long, то все остальные переменные тоже приводятся к long
    // ** Если ни одно из правил не сработало, то все числа приводятся к типу int!
    // Пример:
    byte a=1; 
    byte b=2; 
    byte c = (byte) (a+b); // При сложении двух переменных с типом byte результат будет в int
    // Из-за этого при a += 3 (a = (byte) (a + 3))
```
