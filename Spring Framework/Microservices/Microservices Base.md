# Микросервисы

```palantext
    Микросервисная архитектура — это стиль разработки программного обеспечения, при котором приложение состоит из набора небольших, независимых сервисов, каждый из которых выполняет свою отдельную задачу и взаимодействует с другими сервисами через легковесные механизмы, такие как HTTP API или очереди сообщений. Каждый микросервис отвечает за конкретную функцию приложения, а вся система строится за счет их совместной работы
```

- [Микросервисы](#микросервисы)
  - [Особенности микросервисной архитектуры](#особенности-микросервисной-архитектуры)
  - [Для чего нужна микросервисная архитектура](#для-чего-нужна-микросервисная-архитектура)
  - [Преимущества микросервисной архитектуры по сравнению с монолитной](#преимущества-микросервисной-архитектуры-по-сравнению-с-монолитной)
  - [Недостатки микросервисной архитектуры](#недостатки-микросервисной-архитектуры)
  - [Когда выбирать микросервисы, а когда монолит](#когда-выбирать-микросервисы-а-когда-монолит)
  - [Паттерны в микросервисной архитектуре](#паттерны-в-микросервисной-архитектуре)
    - [API Gateway (Шлюз API)](#api-gateway-шлюз-api)
    - [Service Discovery (Сервис обнаружения)](#service-discovery-сервис-обнаружения)
    - [Circuit Breaker (Предохранитель)](#circuit-breaker-предохранитель)
    - [Saga (Сага)](#saga-сага)
    - [Event Sourcing (Событийное хранилище)](#event-sourcing-событийное-хранилище)
    - [CQRS (Command Query Responsibility Segregation)](#cqrs-command-query-responsibility-segregation)
    - [Database per Service (База данных на сервис)](#database-per-service-база-данных-на-сервис)
    - [Strangler Pattern (Паттерн удава)](#strangler-pattern-паттерн-удава)
    - [Bulkhead (Шлюз/Перегородка)](#bulkhead-шлюзперегородка)
    - [Sidecar (Сайдкар)](#sidecar-сайдкар)
    - [Proxy (Прокси)](#proxy-прокси)
    - [Choreography (Хореография)](#choreography-хореография)
    - [Orchestration (Оркестрация)](#orchestration-оркестрация)

## Особенности микросервисной архитектуры

1. Сервисы слабо связаны между собой и взаимодействуют только через API
2. Каждый сервис имеет собственную базу данных (Свою схему в базе данных). Сервис не должен залезать не в свою схему в базе даннх
3. Структуру данных сервиса можно менять на этапе разработки, не координируя свои действия с разработчиками других сервисов

## Для чего нужна микросервисная архитектура

1. **Масштабируемость:** В современных приложениях может потребоваться гибкость в масштабировании отдельных компонентов. Например, если одна часть системы (например, поиск или обработка платежей) испытывает высокую нагрузку, можно масштабировать только этот сервис, не затрагивая остальные компоненты системы.

2. **Управляемость и модульность:** Каждая часть приложения разбита на отдельные сервисы, что делает код более управляемым и модульным. Легче вносить изменения в одну часть системы, не затрагивая остальные.

3. **Независимая разработка:** Команды могут разрабатывать и деплоить отдельные микросервисы независимо друг от друга. Это особенно полезно в больших компаниях с несколькими командами разработчиков, которые могут параллельно работать над разными частями системы.

4. **Устойчивость к сбоям:** Ошибка в одном микросервисе не обязательно приводит к падению всей системы, так как остальные сервисы продолжают функционировать независимо. Это делает систему более устойчивой и надежной.

## Преимущества микросервисной архитектуры по сравнению с монолитной

1. **Масштабируемость:**
   - **Монолит:** Масштабирование приложения возможно только целиком, даже если нагрузка возникает только на одном его компоненте. Это может быть неэффективно с точки зрения использования ресурсов.
   - **Микросервисы:** Позволяют масштабировать только нужные компоненты, что более эффективно.

2. **Гибкость в разработке и деплое:**
   - **Монолит:** Любое изменение требует пересборки и перезапуска всего приложения. Это делает сложными частые обновления.
   - **Микросервисы:** Отдельные части приложения можно обновлять независимо друг от друга. Команды могут использовать разные технологии и языки программирования для каждого микросервиса.

3. **Управляемость:**
   - **Монолит:** Со временем монолитные системы становятся все более сложными в поддержке и разработке, так как весь код находится в одном месте.
   - **Микросервисы:** Облегчают управление кодом, так как каждый сервис отвечает за свою маленькую область ответственности.

4. **Независимость команд:**
   - **Монолит:** Все изменения в коде могут потенциально затронуть любую другую часть системы, что замедляет процесс разработки.
   - **Микросервисы:** Команды могут работать над разными микросервисами параллельно, не мешая друг другу.

5. **Локализация сбоев:**
   - **Монолит:** Ошибка в одной части системы может вызвать сбой всего приложения.
   - **Микросервисы:** Ошибки ограничиваются конкретным сервисом. Даже если один сервис выйдет из строя, другие могут продолжить работу.

6. **Использование разных технологий:**
   - **Монолит:** Как правило, приложение строится на одном стеке технологий.
   - **Микросервисы:** Каждая команда может выбрать технологии, наиболее подходящие для конкретной задачи, будь то язык программирования, база данных или подход к масштабированию.

## Недостатки микросервисной архитектуры

1. **Сложность разработки и отладки:** В микросервисной архитектуре необходимо организовывать взаимодействие между сервисами, что увеличивает сложность. Также усложняется отладка и тестирование из-за наличия множества компонентов.

2. **Сложности в управлении данными:** Разные микросервисы могут использовать разные базы данных, что создает проблемы с целостностью данных и синхронизацией между сервисами.

3. **Затраты на инфраструктуру:** Микросервисы требуют большего количества ресурсов для поддержки (контейнеры, оркестраторы, мониторинг, сети), что может повысить расходы на инфраструктуру.

4. **Взаимодействие сервисов:** Появляется необходимость надежного межсервисного взаимодействия и маршрутизации запросов, что усложняет архитектуру.

## Когда выбирать микросервисы, а когда монолит

- **Микросервисы:** Подходят для крупных и сложных проектов, где необходимо масштабировать отдельные компоненты, обеспечивать высокую доступность и управляемость. Также это лучший выбор для команд, которые хотят разрабатывать и развертывать разные части системы независимо друг от друга.

- **Монолит:** Вполне подходящий вариант для небольших приложений с простыми требованиями. В начале разработки нового проекта монолит может быть проще и быстрее в реализации, так как не требует сложной инфраструктуры и взаимодействия между компонентами.

В общем, выбор между микросервисами и монолитом зависит от специфики приложения, масштабов проекта, доступных ресурсов и планов на будущее развитие системы

## Паттерны в микросервисной архитектуре

При построении микросервисной архитектуры существуют различные **паттерны**, которые помогают решать общие задачи и проблемы, связанные с управлением микросервисами, их взаимодействием, масштабированием, обработкой ошибок и безопасностью. Рассмотрим основные паттерны, используемые в микросервисной архитектуре.

### API Gateway (Шлюз API)

**Описание:** Шлюз API — это точка входа для всех внешних запросов к микросервисам. Он принимает запросы от клиентов, распределяет их между соответствующими микросервисами, агрегирует ответы и отправляет их обратно клиенту.
**Задачи:**

- Скрытие внутренней структуры системы (микросервисов) от клиента.
- Обеспечение безопасности (аутентификация, авторизация).
- Управление версиями API.
- Балансировка нагрузки.
**Примеры:** Nginx, Kong, AWS API Gateway.

### Service Discovery (Сервис обнаружения)

**Описание:** Система обнаружения сервисов позволяет микросервисам находить друг друга в распределенной среде. Так как микросервисы могут динамически запускаться и останавливаться (например, в контейнерах), их адреса и порты могут изменяться.
**Задачи:**

- Автоматическая регистрация новых сервисов.
- Поиск активных сервисов другими микросервисами.
- Деконфликт адресов и портов при динамическом изменении состояния сервисов.
**Примеры:** Consul, Eureka, Zookeeper.

### Circuit Breaker (Предохранитель)

**Описание:** Паттерн «предохранитель» помогает избежать катастрофических отказов в системе при сбое какого-либо микросервиса. Если сервис начинает работать некорректно (например, из-за перегрузки), предохранитель разрывает соединение и предотвращает дальнейшие запросы до восстановления нормальной работы.
**Задачи:**

- Предотвращение каскадных отказов системы.
- Избежание перегрузки сервисов, которые работают с проблемами.
- Повышение устойчивости к сбоям.
**Примеры:** Hystrix (от Netflix), Resilience4j.

### Saga (Сага)

**Описание:** Паттерн «Сага» используется для управления распределенными транзакциями. В микросервисной архитектуре выполнение одной бизнес-операции часто требует взаимодействия нескольких сервисов, что затрудняет использование традиционных ACID-транзакций. Сага разбивает такую операцию на серию локальных транзакций, каждая из которых является самостоятельной и завершается отдельно.
**Задачи:**

- Поддержка согласованности данных между микросервисами.
- Организация компенсационных транзакций для отмены предыдущих действий, если происходит сбой.
**Примеры реализации:** Оркестратор (централизованное управление транзакциями) или Хореография (событийное управление).

### Event Sourcing (Событийное хранилище)

**Описание:** Вместо хранения текущего состояния данных, Event Sourcing сохраняет все изменения состояния системы в виде последовательности событий. Эти события могут воспроизводиться для восстановления текущего состояния.
**Задачи:**

- Позволяет точно отслеживать все изменения в системе.
- Поддержка восстановления системы и отката действий.
- Полная история изменений состояния объектов.
**Примеры:** Kafka, EventStore.

### CQRS (Command Query Responsibility Segregation)

**Описание:** CQRS разделяет операции изменения данных (команды) и операции чтения данных (запросы). В микросервисной архитектуре это полезно для разделения нагрузки и упрощения обработки разных типов запросов.
**Задачи:**

- Улучшение производительности системы, особенно при высоких нагрузках на чтение.
- Позволяет использовать разные модели данных для чтения и записи.
**Примеры:** Использование отдельных баз данных для чтения и записи.

### Database per Service (База данных на сервис)

**Описание:** В микросервисной архитектуре каждый сервис управляет собственной базой данных, что способствует независимости и автономности сервисов.
**Задачи:**

- Минимизация зависимости между сервисами.
- Обеспечение независимого выбора технологии хранения данных для каждого сервиса.
- Улучшение масштабируемости и производительности.
**Минусы:** Сложность в управлении транзакциями и согласованностью данных между сервисами.

### Strangler Pattern (Паттерн удава)

**Описание:** Паттерн используется для постепенного перевода монолитных приложений на микросервисную архитектуру. Он заключается в том, что новые функциональности разрабатываются в виде микросервисов, в то время как старые части монолита постепенно «удушаются» (заменяются микросервисами).
**Задачи:**

- Упрощение миграции с монолита на микросервисную архитектуру.
- Постепенная замена старого кода без полного переписывания системы.
**Примеры:** Внедрение новых API и сервисов, работающих вместе с существующим монолитом, с последующим выведением старого кода из эксплуатации.

### Bulkhead (Шлюз/Перегородка)

**Описание:** Паттерн «перегородка» изолирует разные части системы друг от друга, предотвращая распространение сбоев. Это можно представить как создание отдельных «отсеков» в корабле: если один отсек «зальет водой», остальные останутся в безопасности.
**Задачи:**

- Повышение устойчивости к сбоям.
- Ограничение ресурсоемких процессов в одной части системы, чтобы другие компоненты не пострадали.
**Примеры:** Разделение потоков обработки запросов или создание разных пулов для критичных и некритичных задач.

### Sidecar (Сайдкар)

**Описание:** В этом паттерне вспомогательный сервис (сайдкар) разворачивается рядом с основным микросервисом в одном контейнере или виртуальной машине. Сайдкар может выполнять такие задачи, как мониторинг, маршрутизация, логирование, кэширование и другие вспомогательные функции.
**Задачи:**

- Обеспечение горизонтальной масштабируемости и независимости основного сервиса от вспомогательных функций.
- Централизованное управление повторяющимися задачами.
**Примеры:** Envoy, Istio для реализации сервисной сетки (service mesh).

### Proxy (Прокси)

**Описание:** Прокси-сервисы используются для маршрутизации запросов между микросервисами. Они могут обеспечивать балансировку нагрузки, кэширование, а также безопасность и фильтрацию запросов.
**Задачи:**

- Упрощение маршрутизации внутри распределенной системы.
- Оптимизация производительности за счет кэширования и снижения нагрузки.
**Примеры:** Envoy, Linkerd.

### Choreography (Хореография)

**Описание:** В хореографии микросервисы взаимодействуют друг с другом посредством событий и сообщений, без централизованного оркестратора. Каждый микросервис реагирует на события и выполняет свою работу.
**Задачи:**

- Повышение гибкости и адаптивности системы.
- Ослабление связей между сервисами.
**Примеры:** Kafka, RabbitMQ для обработки событий.

### Orchestration (Оркестрация)

**Описание:** В противоположность хореографии, оркестрация предполагает наличие центрального компонента (оркестратора), который управляет выполнением операций в микросервисах. Это может быть необходимо для сложных бизнес-процессов.
**Задачи:**

- Централизованное управление сложными бизнес-процессами.
- Согласованное выполнение операций.
**Примеры:** Kubernetes для управления контейнерами, Camunda для бизнес-процессов.

Эти паттерны помогают эффективно разрабатывать, управлять и масштабировать системы, построенные на микросервисной архитектуре, обеспечивая стабильность, безопасность и гибкость в распределенных системах.
