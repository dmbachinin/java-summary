# Микросервисы

```palantext
    Микросервисная архитектура — это стиль разработки программного обеспечения, при котором приложение состоит из набора небольших, независимых сервисов, каждый из которых выполняет свою отдельную задачу и взаимодействует с другими сервисами через легковесные механизмы, такие как HTTP API или очереди сообщений. Каждый микросервис отвечает за конкретную функцию приложения, а вся система строится за счет их совместной работы
```

- [Микросервисы](#микросервисы)
  - [Особенности микросервисной архитектуры](#особенности-микросервисной-архитектуры)
  - [Для чего нужна микросервисная архитектура](#для-чего-нужна-микросервисная-архитектура)
  - [Преимущества микросервисной архитектуры по сравнению с монолитной](#преимущества-микросервисной-архитектуры-по-сравнению-с-монолитной)
  - [Недостатки микросервисной архитектуры](#недостатки-микросервисной-архитектуры)
  - [Когда выбирать микросервисы, а когда монолит](#когда-выбирать-микросервисы-а-когда-монолит)
  - [API Gateway (Шлюз API)](#api-gateway-шлюз-api)
    - [Для чего используется API Gateway?](#для-чего-используется-api-gateway)
  - [Service Discovery (Сервис обнаружения)](#service-discovery-сервис-обнаружения)
    - [Компоненты Service Discovery](#компоненты-service-discovery)
    - [Типы Service Discovery](#типы-service-discovery)
      - [Клиентское обнаружение (Client-side discovery)](#клиентское-обнаружение-client-side-discovery)
      - [Серверное обнаружение (Server-side discovery)](#серверное-обнаружение-server-side-discovery)
    - [Примеры реализаций Service Discovery](#примеры-реализаций-service-discovery)
  - [Circuit Breaker (Предохранитель)](#circuit-breaker-предохранитель)
  - [Saga (Сага)](#saga-сага)
  - [Event Sourcing (Событийное хранилище)](#event-sourcing-событийное-хранилище)
  - [CQRS (Command Query Responsibility Segregation)](#cqrs-command-query-responsibility-segregation)
  - [Database per Service (База данных на сервис)](#database-per-service-база-данных-на-сервис)
  - [Strangler Pattern (Паттерн удава)](#strangler-pattern-паттерн-удава)
  - [Bulkhead (Шлюз/Перегородка)](#bulkhead-шлюзперегородка)
  - [Sidecar (Сайдкар)](#sidecar-сайдкар)
  - [Proxy (Прокси)](#proxy-прокси)
  - [Choreography (Хореография)](#choreography-хореография)
  - [Orchestration (Оркестрация)](#orchestration-оркестрация)

## Особенности микросервисной архитектуры

1. Сервисы слабо связаны между собой и взаимодействуют только через API
2. Каждый сервис имеет собственную базу данных (Свою схему в базе данных). Сервис не должен залезать не в свою схему в базе даннх
3. Структуру данных сервиса можно менять на этапе разработки, не координируя свои действия с разработчиками других сервисов

## Для чего нужна микросервисная архитектура

1. **Масштабируемость:** В современных приложениях может потребоваться гибкость в масштабировании отдельных компонентов. Например, если одна часть системы (например, поиск или обработка платежей) испытывает высокую нагрузку, можно масштабировать только этот сервис, не затрагивая остальные компоненты системы.

2. **Управляемость и модульность:** Каждая часть приложения разбита на отдельные сервисы, что делает код более управляемым и модульным. Легче вносить изменения в одну часть системы, не затрагивая остальные.

3. **Независимая разработка:** Команды могут разрабатывать и деплоить отдельные микросервисы независимо друг от друга. Это особенно полезно в больших компаниях с несколькими командами разработчиков, которые могут параллельно работать над разными частями системы.

4. **Устойчивость к сбоям:** Ошибка в одном микросервисе не обязательно приводит к падению всей системы, так как остальные сервисы продолжают функционировать независимо. Это делает систему более устойчивой и надежной.

## Преимущества микросервисной архитектуры по сравнению с монолитной

1. **Масштабируемость:**
   - **Монолит:** Масштабирование приложения возможно только целиком, даже если нагрузка возникает только на одном его компоненте. Это может быть неэффективно с точки зрения использования ресурсов.
   - **Микросервисы:** Позволяют масштабировать только нужные компоненты, что более эффективно.

2. **Гибкость в разработке и деплое:**
   - **Монолит:** Любое изменение требует пересборки и перезапуска всего приложения. Это делает сложными частые обновления.
   - **Микросервисы:** Отдельные части приложения можно обновлять независимо друг от друга. Команды могут использовать разные технологии и языки программирования для каждого микросервиса.

3. **Управляемость:**
   - **Монолит:** Со временем монолитные системы становятся все более сложными в поддержке и разработке, так как весь код находится в одном месте.
   - **Микросервисы:** Облегчают управление кодом, так как каждый сервис отвечает за свою маленькую область ответственности.

4. **Независимость команд:**
   - **Монолит:** Все изменения в коде могут потенциально затронуть любую другую часть системы, что замедляет процесс разработки.
   - **Микросервисы:** Команды могут работать над разными микросервисами параллельно, не мешая друг другу.

5. **Локализация сбоев:**
   - **Монолит:** Ошибка в одной части системы может вызвать сбой всего приложения.
   - **Микросервисы:** Ошибки ограничиваются конкретным сервисом. Даже если один сервис выйдет из строя, другие могут продолжить работу.

6. **Использование разных технологий:**
   - **Монолит:** Как правило, приложение строится на одном стеке технологий.
   - **Микросервисы:** Каждая команда может выбрать технологии, наиболее подходящие для конкретной задачи, будь то язык программирования, база данных или подход к масштабированию.

## Недостатки микросервисной архитектуры

1. **Сложность разработки и отладки:** В микросервисной архитектуре необходимо организовывать взаимодействие между сервисами, что увеличивает сложность. Также усложняется отладка и тестирование из-за наличия множества компонентов.

2. **Сложности в управлении данными:** Разные микросервисы могут использовать разные базы данных, что создает проблемы с целостностью данных и синхронизацией между сервисами.

3. **Затраты на инфраструктуру:** Микросервисы требуют большего количества ресурсов для поддержки (контейнеры, оркестраторы, мониторинг, сети), что может повысить расходы на инфраструктуру.

4. **Взаимодействие сервисов:** Появляется необходимость надежного межсервисного взаимодействия и маршрутизации запросов, что усложняет архитектуру.

## Когда выбирать микросервисы, а когда монолит

- **Микросервисы:** Подходят для крупных и сложных проектов, где необходимо масштабировать отдельные компоненты, обеспечивать высокую доступность и управляемость. Также это лучший выбор для команд, которые хотят разрабатывать и развертывать разные части системы независимо друг от друга.

- **Монолит:** Вполне подходящий вариант для небольших приложений с простыми требованиями. В начале разработки нового проекта монолит может быть проще и быстрее в реализации, так как не требует сложной инфраструктуры и взаимодействия между компонентами.

В общем, выбор между микросервисами и монолитом зависит от специфики приложения, масштабов проекта, доступных ресурсов и планов на будущее развитие системы

## API Gateway (Шлюз API)

**API Gateway** — это сервер-прокси, который стоит между клиентом и набором микросервисов в системе. Он отвечает за маршрутизацию, управление запросами и выполнение ряда других задач, связанных с обработкой API-запросов. API Gateway действует как единственная точка входа для всех клиентов, которые взаимодействуют с распределенной системой

**Примеры популярных API Gateway решений:**

- `Kong`: Высокопроизводительный API Gateway с поддержкой плагинов для добавления функционала (например, логирование, аутентификация).
- `NGINX`: Может быть использован как API Gateway, предоставляя высокую производительность и гибкость настройки.
- `Spring Cloud Gateway`: Популярное решение в экосистеме Spring для микросервисных архитектур на базе Java.
- `AWS API Gateway`: Решение от Amazon для облачных микросервисов, которое тесно интегрируется с другими сервисами AWS.

### Для чего используется API Gateway?

API Gateway выполняет несколько ключевых функций, и его использование оправдано в архитектурах на основе микросервисов. Основные функции API Gateway включают:

1. **Маршрутизация запросов**:
   - API Gateway принимает запросы от клиентов и перенаправляет их к соответствующему микросервису. Это упрощает клиентам взаимодействие с системой, так как им не нужно знать об архитектуре или расположении сервисов.

2. **Агрегация ответов**:
   - В некоторых случаях запрос от клиента требует взаимодействия с несколькими микросервисами. API Gateway может взять на себя задачу вызова нескольких сервисов, собрать их ответы и вернуть объединённый результат клиенту.

3. **Безопасность и аутентификация**:
   - API Gateway может служить центром безопасности, проводя проверку токенов аутентификации (OAuth, JWT и другие) и реализуя механизмы авторизации, прежде чем передать запрос к микросервисам.

4. **Управление трафиком**:
   - API Gateway позволяет ограничивать скорость запросов (rate limiting) для предотвращения перегрузки сервисов, а также обеспечивает балансировку нагрузки между несколькими экземплярами одного сервиса.

5. **Кэширование**:
   - Gateway может выполнять кэширование ответов, чтобы уменьшить нагрузку на микросервисы и сократить время отклика для клиентов.

6. **Трансформация запросов и ответов**:
   - В зависимости от требований клиента и микросервиса, API Gateway может изменять формат данных. Например, преобразовать XML в JSON или добавить дополнительные заголовки.

7. **Логирование и мониторинг**:
   - API Gateway может собирать логи, метрики и другую информацию о запросах и ответах, что упрощает мониторинг производительности и отладку.

8. **Оркестрация и взаимодействие с микросервисами**:
   - В сложных системах API Gateway может выполнять оркестрацию запросов: последовательное или параллельное выполнение нескольких операций, которые должны быть объединены в одном запросе.

## Service Discovery (Сервис обнаружения)

**Service Discovery** — это паттерн, используемый в распределенных системах (например, в микросервисной архитектуре), чтобы обеспечить автоматическое обнаружение и взаимодействие сервисов друг с другом. В системе, состоящей из множества сервисов, важной задачей становится возможность динамически находить адреса и порты других сервисов, которые могут изменяться со временем (например, при масштабировании или перезапуске контейнеров)

**Для чего нужен Service Discovery?**

В традиционных монолитных приложениях все компоненты находятся в одном пространстве и могут легко взаимодействовать друг с другом. Однако в микросервисной архитектуре приложение разбивается на множество отдельных сервисов, которые могут работать на разных серверах, в разных контейнерах или даже в разных дата-центрах. Адреса этих сервисов могут часто изменяться из-за:

- Масштабирования (динамическое добавление или удаление экземпляров).
- Сбоев (серверы могут падать, и новые сервисы могут быть развернуты на других узлах).
- Обновлений и перезапусков.

В этих условиях появляется задача:

- Как другим сервисам или клиентам узнать, где находятся сервисы, чтобы с ними взаимодействовать?
- Как сделать это динамически, без необходимости каждый раз изменять конфигурации вручную?

Вот тут и нужен **Service Discovery**, который автоматизирует процесс обнаружения сервисов и поддерживает актуальные данные о местоположении (адреса, порты) активных сервисов.

### Компоненты Service Discovery

1. **Service Registry (Реестр сервисов)**:
   - Это централизованное хранилище информации о сервисах. Сюда каждый сервис регистрируется с указанием своего адреса, порта и других метаданных. Когда новый экземпляр сервиса запускается, он регистрируется в реестре, а когда сервис прекращает работу, он удаляется из реестра.
   - Пример: **Eureka**, **Consul**, **Zookeeper**.

2. **Service Providers (Поставщики сервисов)**:
   - Это сервисы, которые регистрируют себя в реестре. Они могут динамически присоединяться к системе, масштабироваться или завершать работу.

3. **Service Consumers (Потребители сервисов)**:
   - Это сервисы или приложения, которые запрашивают реестр сервисов, чтобы узнать, где находятся другие сервисы, и затем взаимодействовать с ними.

4. **Discovery Agent (Агент обнаружения)**:
   - Механизм, который отвечает за получение информации о доступных сервисах из реестра и обновление состояния потребителей сервисов.

### Типы Service Discovery

Существует два основных типа паттерна Service Discovery:

#### Клиентское обнаружение (Client-side discovery)

- При этом подходе клиент (то есть потребитель) напрямую взаимодействует с реестром сервисов. Он сам запрашивает реестр, чтобы найти адреса нужных сервисов, а затем взаимодействует с найденными сервисами.
- Преимущество: Прямое взаимодействие с реестром, что уменьшает сложность и уменьшает задержку, так как запросы идут напрямую.
- Недостаток: Каждый клиент должен реализовывать логику взаимодействия с реестром сервисов, что может усложнить код и его поддержку.

**Порядок работы**:

1. Сервис регистрируется в реестре.
2. Клиент запрашивает у реестра информацию о доступных сервисах.
3. Клиент напрямую взаимодействует с сервисом, балансируя запросы, если требуется.

#### Серверное обнаружение (Server-side discovery)

- В этом случае клиент отправляет запрос на API Gateway или Load Balancer, и тот уже взаимодействует с реестром сервисов, чтобы найти нужный сервис, а затем перенаправляет запрос клиента к нему.
- Преимущество: Логика обнаружения сервисов инкапсулирована на стороне сервера, что упрощает код клиента.
- Недостаток: Необходима дополнительная конфигурация для API Gateway или балансировщика нагрузки.

**Порядок работы**:

1. Клиент отправляет запрос к API Gateway или Load Balancer.
2. API Gateway взаимодействует с реестром сервисов, чтобы найти актуальные экземпляры сервисов.
3. Gateway перенаправляет запрос к нужному сервису.

### Примеры реализаций Service Discovery

1. **Netflix Eureka**:
   - Один из самых популярных вариантов Service Discovery, особенно в экосистеме Spring Cloud.
   - В Netflix Eureka каждый микросервис регистрируется на сервере Eureka. Клиенты могут взаимодействовать с Eureka, чтобы получить адреса других сервисов. Eureka поддерживает также проверки "жизни" сервисов (heartbeat), чтобы убедиться, что сервисы активны.

2. **Consul**:
   - Consul предоставляет мощный механизм Service Discovery вместе с возможностями управления конфигурацией и мониторинга.
   - Consul также использует HTTP-интерфейсы для регистрации и обнаружения сервисов и поддерживает распределенную природу системы.

3. **Apache Zookeeper**:
   - Zookeeper используется не только для Service Discovery, но и для управления конфигурацией и синхронизации распределенных систем.
   - Он поддерживает централизованное управление регистрацией сервисов и отслеживает состояние сервисов в реальном времени.

4. **Kubernetes Service Discovery**:
   - Kubernetes встроенно поддерживает Service Discovery через свои механизмы. Сервисы регистрируются автоматически в DNS Kubernetes или через балансировщик нагрузки, что упрощает обнаружение и взаимодействие между ними.

## Circuit Breaker (Предохранитель)

**Описание:** Паттерн «предохранитель» помогает избежать катастрофических отказов в системе при сбое какого-либо микросервиса. Если сервис начинает работать некорректно (например, из-за перегрузки), предохранитель разрывает соединение и предотвращает дальнейшие запросы до восстановления нормальной работы.
**Задачи:**

- Предотвращение каскадных отказов системы.
- Избежание перегрузки сервисов, которые работают с проблемами.
- Повышение устойчивости к сбоям.
**Примеры:** Hystrix (от Netflix), Resilience4j.

## Saga (Сага)

**Описание:** Паттерн «Сага» используется для управления распределенными транзакциями. В микросервисной архитектуре выполнение одной бизнес-операции часто требует взаимодействия нескольких сервисов, что затрудняет использование традиционных ACID-транзакций. Сага разбивает такую операцию на серию локальных транзакций, каждая из которых является самостоятельной и завершается отдельно.
**Задачи:**

- Поддержка согласованности данных между микросервисами.
- Организация компенсационных транзакций для отмены предыдущих действий, если происходит сбой.
**Примеры реализации:** Оркестратор (централизованное управление транзакциями) или Хореография (событийное управление).

## Event Sourcing (Событийное хранилище)

**Описание:** Вместо хранения текущего состояния данных, Event Sourcing сохраняет все изменения состояния системы в виде последовательности событий. Эти события могут воспроизводиться для восстановления текущего состояния.
**Задачи:**

- Позволяет точно отслеживать все изменения в системе.
- Поддержка восстановления системы и отката действий.
- Полная история изменений состояния объектов.
**Примеры:** Kafka, EventStore.

## CQRS (Command Query Responsibility Segregation)

**Описание:** CQRS разделяет операции изменения данных (команды) и операции чтения данных (запросы). В микросервисной архитектуре это полезно для разделения нагрузки и упрощения обработки разных типов запросов.
**Задачи:**

- Улучшение производительности системы, особенно при высоких нагрузках на чтение.
- Позволяет использовать разные модели данных для чтения и записи.
**Примеры:** Использование отдельных баз данных для чтения и записи.

## Database per Service (База данных на сервис)

**Описание:** В микросервисной архитектуре каждый сервис управляет собственной базой данных, что способствует независимости и автономности сервисов.
**Задачи:**

- Минимизация зависимости между сервисами.
- Обеспечение независимого выбора технологии хранения данных для каждого сервиса.
- Улучшение масштабируемости и производительности.
**Минусы:** Сложность в управлении транзакциями и согласованностью данных между сервисами.

## Strangler Pattern (Паттерн удава)

**Описание:** Паттерн используется для постепенного перевода монолитных приложений на микросервисную архитектуру. Он заключается в том, что новые функциональности разрабатываются в виде микросервисов, в то время как старые части монолита постепенно «удушаются» (заменяются микросервисами).
**Задачи:**

- Упрощение миграции с монолита на микросервисную архитектуру.
- Постепенная замена старого кода без полного переписывания системы.
**Примеры:** Внедрение новых API и сервисов, работающих вместе с существующим монолитом, с последующим выведением старого кода из эксплуатации.

## Bulkhead (Шлюз/Перегородка)

**Описание:** Паттерн «перегородка» изолирует разные части системы друг от друга, предотвращая распространение сбоев. Это можно представить как создание отдельных «отсеков» в корабле: если один отсек «зальет водой», остальные останутся в безопасности.
**Задачи:**

- Повышение устойчивости к сбоям.
- Ограничение ресурсоемких процессов в одной части системы, чтобы другие компоненты не пострадали.
**Примеры:** Разделение потоков обработки запросов или создание разных пулов для критичных и некритичных задач.

## Sidecar (Сайдкар)

**Описание:** В этом паттерне вспомогательный сервис (сайдкар) разворачивается рядом с основным микросервисом в одном контейнере или виртуальной машине. Сайдкар может выполнять такие задачи, как мониторинг, маршрутизация, логирование, кэширование и другие вспомогательные функции.
**Задачи:**

- Обеспечение горизонтальной масштабируемости и независимости основного сервиса от вспомогательных функций.
- Централизованное управление повторяющимися задачами.
**Примеры:** Envoy, Istio для реализации сервисной сетки (service mesh).

## Proxy (Прокси)

**Описание:** Прокси-сервисы используются для маршрутизации запросов между микросервисами. Они могут обеспечивать балансировку нагрузки, кэширование, а также безопасность и фильтрацию запросов.
**Задачи:**

- Упрощение маршрутизации внутри распределенной системы.
- Оптимизация производительности за счет кэширования и снижения нагрузки.
**Примеры:** Envoy, Linkerd.

## Choreography (Хореография)

**Описание:** В хореографии микросервисы взаимодействуют друг с другом посредством событий и сообщений, без централизованного оркестратора. Каждый микросервис реагирует на события и выполняет свою работу.
**Задачи:**

- Повышение гибкости и адаптивности системы.
- Ослабление связей между сервисами.
**Примеры:** Kafka, RabbitMQ для обработки событий.

## Orchestration (Оркестрация)

**Описание:** В противоположность хореографии, оркестрация предполагает наличие центрального компонента (оркестратора), который управляет выполнением операций в микросервисах. Это может быть необходимо для сложных бизнес-процессов.
**Задачи:**

- Централизованное управление сложными бизнес-процессами.
- Согласованное выполнение операций.
**Примеры:** Kubernetes для управления контейнерами, Camunda для бизнес-процессов.

Эти паттерны помогают эффективно разрабатывать, управлять и масштабировать системы, построенные на микросервисной архитектуре, обеспечивая стабильность, безопасность и гибкость в распределенных системах.
