# Справочная информация для собеседований

- [Справочная информация для собеседований](#справочная-информация-для-собеседований)
  - [Принципы ООП](#принципы-ооп)
    - [Инкапсуляция](#инкапсуляция)
    - [Наследование](#наследование)
    - [Полиморфизм](#полиморфизм)
    - [Абстракция](#абстракция)
  - [Принципы SOLID](#принципы-solid)
    - [Принцип единственной ответственности (Single Responsibility Principle, SRP)](#принцип-единственной-ответственности-single-responsibility-principle-srp)
    - [Принцип Открыто-Закрыто (Open/Closed Principle, OCP)](#принцип-открыто-закрыто-openclosed-principle-ocp)
    - [Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)](#принцип-подстановки-барбары-лисков-liskov-substitution-principle-lsp)
    - [Принцип разделения интерфейса (Interface Segregation Principle, ISP)](#принцип-разделения-интерфейса-interface-segregation-principle-isp)
    - [Принцип инверсии зависимости (Dependency Inversion Principle, DIP)](#принцип-инверсии-зависимости-dependency-inversion-principle-dip)
  - [Уровни изоляции транзакций](#уровни-изоляции-транзакций)
    - [Виды ошибок, которые могут возникать с транзакциями](#виды-ошибок-которые-могут-возникать-с-транзакциями)
      - [Грязное чтение (Dirty Read)](#грязное-чтение-dirty-read)
    - [Неповторяющееся чтение (Non-Repeatable Read)](#неповторяющееся-чтение-non-repeatable-read)
    - [Фантомное чтение (Phantom Read)](#фантомное-чтение-phantom-read)
    - [Read Uncommitted (чтение незафиксированных данных)](#read-uncommitted-чтение-незафиксированных-данных)
    - [Read Committed (чтение подтверждённых данных)](#read-committed-чтение-подтверждённых-данных)
    - [Repeatable Read (повторяемое чтение)](#repeatable-read-повторяемое-чтение)
    - [Serializable (сериализуемость)](#serializable-сериализуемость)

## Принципы ООП

### Инкапсуляция

**Инкапсуляция** - это процесс сокрытия реализации детялей реализации объекта от внешнего мира и предоствление интерфейса для взаимодействия с этим объектом

**Суть принципа:** вся важная информация, необходимая для работы объекта, в нем же и хранится. И только определенные данные доступны для внешних функций о объектов.

### Наследование

**Наследование** - это концепция, согласно которой одни классы (родители) могут лежать в основе других классов, наследоников. При этом дочерние классы перенимают все свойства и методы родительского класса с возможностью дополнять и модифицировать их.

### Полиморфизм

**Полиморфизм** — это способность объекта работать с данными разных типов

**Полиморфизм** предполагает использование одного и того же имени метода или свойства для объектов разных классов. Иными словами, полиморфизм позволяет обращаться к объектам разных классов с помощью одних и тех же методов или свойств

Работа полиморфизма основывается на наследовании и переопределении методов в наследниках. Когда мы создаем новый класс, наследующий свойства и методы от родительского класса, мы можем переопределить некоторые методы в наследнике. Таким образом, если у нас есть переменная с типом родительского класса, то ее можно использовать для хранения экземпляра любого из наследников этого класса. При вызове метода через эту переменную будет вызываться метод из соответствующего наследника

Еще один способ реализации полиморфизма - это использование интерфейсов. Интерфейс определяет набор методов, которые должны быть реализованы всеми классами, которые реализуют этот интерфейс. Это позволяет использовать объекты разных классов, которые реализуют один и тот же интерфейс, как если бы это были объекты одного класса

**Пример:**

```java
  public class Animal {
    public void makeSound() {
        System.out.println("Animal is making a sound");
    }
  }

  public class Dog extends Animal {
    public void makeSound() {
        System.out.println("Dog is barking");
    }
  }

  public class Cat extends Animal {
    public void makeSound() {
        System.out.println("Cat is meowing");
    }
  }

  public class Main {
    public static void main(String[] args) {
        Animal animal1 = new Dog(); // Полиморфизм
        Animal animal2 = new Cat(); // Полиморфизм
        animal1.makeSound();
        animal2.makeSound();
    }
  }
```

### Абстракция

Принцип абстракции означает, что детали реализации объектов должны быть скрыты от других объектов, которые используют эти объекты, и доступны только интерфейсы.

Принцип абстракции является одним из основных принципов ООП и обеспечивает более высокий уровень абстракции в программировании.

## Принципы SOLID

### Принцип единственной ответственности (Single Responsibility Principle, SRP)

Каждый класс должен выполнять только одну поставленную перед ним задачу. Класс должен содержать единую логическую связанную функциональность.

### Принцип Открыто-Закрыто (Open/Closed Principle, OCP)

Программные сущности должны быть открыты для расширения, но закрыты для изменения. Можно добавлять новый функционал, но нельзя изменять старый. Если при добавлении нового функционала необходимо менять исходный код уже написанных методо, то это нарушение метода.

### Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)

Производные классы только расширают функциональность исходного кода, не изменяя ее. Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом.

### Принцип разделения интерфейса (Interface Segregation Principle, ISP)

«Клиенты не должны зависеть от методов, которые они не используют». Слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе

### Принцип инверсии зависимости (Dependency Inversion Principle, DIP)

Классы должны зависеть от абстракций, а не от конкретных реализаций. Высокоуровневые модули не должны зависеть от низкоуровневых модулей. Все зависимости в программе должны поддерживаться за счет абстрактных классов или интерфейсов.

## Уровни изоляции транзакций

### Виды ошибок, которые могут возникать с транзакциями

Эти три термина — *грязное чтение*, *неповторяющееся чтение* и *фантомное чтение* — относятся к видам ошибок, которые могут возникать при параллельной работе с базами данных и при использовании различных уровней изоляции транзакций. Важно понимать их, чтобы правильно управлять параллелизмом и обеспечивать целостность данных в системах.

#### Грязное чтение (Dirty Read)

**Грязное чтение** происходит, когда одна транзакция считывает данные, которые были изменены другой транзакцией, но ещё не были зафиксированы. Если вторая транзакция откатится, то данные окажутся некорректными, так как первая транзакция уже использовала несохранённые изменения.

**Пример:**

- Транзакция A изменяет значение записи, но ещё не завершена.
- Транзакция B читает изменённое значение.
- Транзакция A отменяется (откатывается), возвращая исходное значение.
  
В результате транзакция B использовала данные, которые в конечном итоге оказались неверными.

**Решение**: для предотвращения грязного чтения обычно используется уровень изоляции **Read Committed** (чтение фиксированных данных), который не позволяет транзакциям считывать незавершённые изменения других транзакций.

### Неповторяющееся чтение (Non-Repeatable Read)

**Неповторяющееся чтение** возникает, когда одна транзакция дважды читает одну и ту же запись и видит разные значения, так как другая транзакция изменила эти данные между двумя операциями чтения.

**Пример:**

- Транзакция A читает значение записи.
- Транзакция B изменяет и фиксирует новое значение этой записи.
- Транзакция A снова читает значение и видит уже изменённое.

Таким образом, данные при повторном чтении не совпадают с первоначальными, что может нарушить логику операций.

**Решение**: для предотвращения неповторяющегося чтения можно использовать уровень изоляции **Repeatable Read** (повторяющееся чтение), который блокирует записи, читаемые транзакцией, чтобы другие транзакции не могли их изменить до завершения первой транзакции.

### Фантомное чтение (Phantom Read)

**Фантомное чтение** — это случай, когда одна транзакция повторно выполняет запрос на набор данных с определёнными критериями и видит новый результат из-за добавления или удаления записей другой транзакцией. Это не изменения конкретных записей, а именно изменение числа или состава строк.

**Пример:**

- Транзакция A выполняет запрос, например, на выбор всех сотрудников с зарплатой выше определённой суммы.
- Транзакция B добавляет новую запись, соответствующую этим критериям, и фиксирует её.
- Транзакция A снова выполняет запрос с теми же критериями и получает уже изменённый набор строк, включающий новую запись.

Это может нарушить согласованность данных при анализе и отчётности.

**Решение**: для предотвращения фантомного чтения используется уровень изоляции **Serializable** (упорядоченное выполнение), который блокирует диапазоны записей, соответствующих критериям запроса, не позволяя добавлять или удалять строки в этих диапазонах.

### Read Uncommitted (чтение незафиксированных данных)

Самый слабый уровень изоляции, когда транзакия может видеть результат других транзакций, даже если они еще не закоммичены.

Read Uncommitted — по факту, тут изоляция отсутствует. Где‑нибудь в аналитике больших данных такой уровень может ещё использоваться, где нам не так важна точность данных, но это достаточно редко

### Read Committed (чтение подтверждённых данных)

Транзакции видят только подтверждённые изменения других транзакций.

На этом уровне транзакция может читать только те изменения в других параллельных транзакциях, которые уже были закоммичены. Это нас спасает от грязного чтения, но не спасает от неповторяющегося чтения и от фантомного чтения.

### Repeatable Read (повторяемое чтение)

В этом режиме транзакции видят только данные, которые были считаны на момент начала транзакции. Это предотвращает «грязное чтение» и «неповторяющееся чтение», но может привести к «фантомным» записям, когда другая транзакция вставляет новые записи

Этот уровень означает, что пока транзакция не завершится, никто параллельно не может изменять или удалять строки, которые транзакция уже прочитала. Т. е. данные, которые я прочитал своей транзакцией, точно никто не изменит, пока я не завершу свою транзакцию (по крайней мере, в классическом понимании этого уровня с блокировками)

### Serializable (сериализуемость)

Самый строгий уровень изоляции. Транзакции выполняются так, как если бы они выполнялись последовательно. Это предотвращает «грязное чтение», «неповторяющееся чтение» и «фантомные» записи. Однако это может привести к блокировкам и ухудшению производительности

Он блокирует любые действия, пока запущена транзакция — получается, транзакции идут строго одна за другой и максимально изолируются друг от друга. Это достигается с помощью блокировки всей таблицы от любых взаимодействий с ней, но некоторые СУБД делают менее радикально — блокируют только те строки, которые задействует текущая транзакция
